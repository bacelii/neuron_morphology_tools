<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>neuron_morphology_tools.neuron_nx_utils &mdash; neuron_morphology_tools  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=b3ba4146"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            neuron_morphology_tools
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">neuron_morphology_tools</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">neuron_morphology_tools</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">neuron_morphology_tools.neuron_nx_utils</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for neuron_morphology_tools.neuron_nx_utils</h1><div class="highlight"><pre>
<span></span><span class="sd">&#39;&#39;&#39;</span>

<span class="sd">Purpose: tools that will help process a neuron that</span>
<span class="sd">is represented as a networkx graph</span>


<span class="sd">&#39;&#39;&#39;</span>
<span class="kn">from</span> <span class="nn">pykdtree.kdtree</span> <span class="kn">import</span> <span class="n">KDTree</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">numpy_dep</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">soma_node_name_global</span> <span class="o">=</span> <span class="s2">&quot;S0&quot;</span>
<span class="n">node_label</span> <span class="o">=</span> <span class="s2">&quot;u&quot;</span>

<span class="n">auto_proof_filter_name_default</span> <span class="o">=</span> <span class="s2">&quot;auto_proof_filter&quot;</span>

<span class="n">dynamic_attributes_default</span> <span class="o">=</span> <span class="p">(</span>
 <span class="s1">&#39;spine_data&#39;</span><span class="p">,</span>
 <span class="s1">&#39;synapse_data&#39;</span><span class="p">,</span>
 <span class="s1">&#39;width_data&#39;</span><span class="p">,</span>
  <span class="s1">&#39;skeleton_data&#39;</span><span class="p">)</span>


<span class="n">compartments_excitatory</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;apical&#39;</span><span class="p">,</span>
    <span class="s1">&#39;apical_shaft&#39;</span><span class="p">,</span>
    <span class="s1">&#39;apical_tuft&#39;</span><span class="p">,</span>
    <span class="s1">&#39;basal&#39;</span><span class="p">,</span>
    <span class="s1">&#39;axon&#39;</span><span class="p">,</span>
    <span class="s1">&#39;oblique&#39;</span><span class="p">,</span>
<span class="p">]</span>

<span class="n">compartments_inhibitory</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;axon&#39;</span><span class="p">,</span>
    <span class="s1">&#39;dendrite&#39;</span><span class="p">,</span>
<span class="p">]</span>

<span class="n">compartments</span> <span class="o">=</span> <span class="n">compartments_excitatory</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;dendrite&quot;</span><span class="p">]</span>

<span class="n">compartment_colors</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;apical&#39;</span><span class="p">:</span> <span class="s1">&#39;blue&#39;</span><span class="p">,</span>
 <span class="s1">&#39;apical_shaft&#39;</span><span class="p">:</span> <span class="s1">&#39;aqua&#39;</span><span class="p">,</span>
 <span class="s1">&#39;apical_tuft&#39;</span><span class="p">:</span> <span class="s1">&#39;purple&#39;</span><span class="p">,</span>
 <span class="s1">&#39;basal&#39;</span><span class="p">:</span> <span class="s1">&#39;brown&#39;</span><span class="p">,</span>
 <span class="s1">&#39;axon&#39;</span><span class="p">:</span> <span class="s1">&#39;red&#39;</span><span class="p">,</span>
 <span class="s1">&#39;oblique&#39;</span><span class="p">:</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span>
 <span class="s1">&#39;dendrite&#39;</span><span class="p">:</span> <span class="s1">&#39;lightsteelblue&#39;</span><span class="p">,</span>
 <span class="s1">&#39;apical_total&#39;</span><span class="p">:</span> <span class="s1">&#39;magenta&#39;</span><span class="p">,</span>
 <span class="s1">&#39;soma&#39;</span><span class="p">:</span> <span class="s1">&#39;black&#39;</span><span class="p">}</span>


<span class="c1"># --- global parameters for vector computations ---</span>
<span class="n">default_upstream_dist_max</span> <span class="o">=</span> <span class="mi">6000</span>
<span class="n">default_scholl_interval</span> <span class="o">=</span> <span class="mi">10_000</span>




<div class="viewcode-block" id="delete_attributes"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.delete_attributes">[docs]</a><span class="k">def</span> <span class="nf">delete_attributes</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">inplace</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">attributes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">):</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">attributes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">attributes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nxu</span><span class="o">.</span><span class="n">dynamic_attributes_default</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">xu</span><span class="o">.</span><span class="n">delete_node_attributes</span><span class="p">(</span>
        <span class="n">G</span><span class="p">,</span>
        <span class="n">attributes</span><span class="o">=</span><span class="n">attributes</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span></div>


<div class="viewcode-block" id="name_from_G"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.name_from_G">[docs]</a><span class="k">def</span> <span class="nf">name_from_G</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">append</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">graph_attr</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">graph_attr_dict</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="n">segment_id</span> <span class="o">=</span> <span class="n">graph_attr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;segment_id&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">split_index</span> <span class="o">=</span> <span class="n">graph_attr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;split_index&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">nucleus_id</span> <span class="o">=</span> <span class="n">graph_attr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;nucleus_id&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
    
    <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;seg_</span><span class="si">{</span><span class="n">segment_id</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">split_index</span><span class="si">}</span><span class="s2">_nucleus_</span><span class="si">{</span><span class="n">nucleus_id</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">if</span> <span class="n">append</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">append</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">return</span> <span class="n">name</span></div>
    
<div class="viewcode-block" id="save_G"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.save_G">[docs]</a><span class="k">def</span> <span class="nf">save_G</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">filepath</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">filename_append</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">delete_dynamic_attributes</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To save the graph</span>
<span class="sd">    nxu.save_G(G_ax,filename_append=&quot;axon_high_fid&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">delete_dynamic_attributes</span><span class="p">:</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">delete_attributes</span><span class="p">(</span>
            <span class="n">G</span><span class="p">,</span>
            <span class="n">inplace</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">filepath</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">filepath</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;./</span><span class="si">{</span><span class="n">nxu</span><span class="o">.</span><span class="n">name_from_G</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">append</span><span class="o">=</span><span class="n">filename_append</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
    
    <span class="k">return</span> <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">filepath</span><span class="p">)</span></div>

<div class="viewcode-block" id="load_G"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.load_G">[docs]</a><span class="k">def</span> <span class="nf">load_G</span><span class="p">(</span><span class="n">filepath</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">su</span><span class="o">.</span><span class="n">decompress_pickle</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span></div>
    

<div class="viewcode-block" id="skeletal_length_on_path"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.skeletal_length_on_path">[docs]</a><span class="k">def</span> <span class="nf">skeletal_length_on_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">path</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;skeletal_length&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">path</span><span class="p">])</span></div>

<div class="viewcode-block" id="calculate_soma_distance_to_data_objs"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.calculate_soma_distance_to_data_objs">[docs]</a><span class="k">def</span> <span class="nf">calculate_soma_distance_to_data_objs</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">data_to_update</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;synapse_data&quot;</span><span class="p">,</span><span class="s2">&quot;spine_data&quot;</span><span class="p">,</span><span class="s2">&quot;width_data&quot;</span><span class="p">),</span>                     
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To set the soma distance for all attributes</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    Iterate through all of the nodes with L in name</span>
<span class="sd">    1) Find the path back to the soma</span>
<span class="sd">    2) Calculate the sum of skeletal length back to the soma</span>
<span class="sd">    for each attrbute</span>
<span class="sd">    3) Add skeletal length to the upstream dist to get the soma distance</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
        <span class="k">if</span> <span class="s2">&quot;L&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--working on node </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">--&quot;</span><span class="p">)</span>
        <span class="n">inbetween_node_path</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="s2">&quot;S0&quot;</span><span class="p">,</span><span class="n">node</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">data_to_update</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;synapse_data&quot;</span><span class="p">,</span><span class="s2">&quot;spine_data&quot;</span><span class="p">,</span><span class="s2">&quot;width_data&quot;</span><span class="p">)</span>

        <span class="n">soma_dist_on_path</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">skeletal_length_on_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">inbetween_node_path</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;inbetween_node_path = </span><span class="si">{</span><span class="n">inbetween_node_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;soma_dist_on_path = </span><span class="si">{</span><span class="n">soma_dist_on_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="n">data_to_update</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">dtype</span><span class="p">]:</span>
                <span class="n">obj</span><span class="p">[</span><span class="s2">&quot;soma_distance&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span><span class="p">[</span><span class="s2">&quot;upstream_dist&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">soma_dist_on_path</span></div>
                
                
<div class="viewcode-block" id="draw_tree"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.draw_tree">[docs]</a><span class="k">def</span> <span class="nf">draw_tree</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">draw_type</span> <span class="o">=</span> <span class="s2">&quot;dot&quot;</span><span class="p">,</span><span class="c1">#&quot;twopi&quot; (the circular), &quot;circo&quot; (makes square like)</span>
    <span class="n">node_size</span><span class="o">=</span><span class="mi">4000</span><span class="p">,</span>
    <span class="n">font_size</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
    <span class="n">font_color</span> <span class="o">=</span> <span class="s2">&quot;white&quot;</span><span class="p">,</span>
    <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">),</span>
    <span class="n">compartment_colors</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">compartment_color_dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="k">if</span> <span class="n">compartment_colors</span><span class="p">:</span>
        <span class="n">node_color</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">node_compartment_color_dict</span><span class="p">(</span>
            <span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="p">,</span>
            <span class="n">compartment_color_dict</span><span class="o">=</span><span class="n">compartment_color_dict</span>
        <span class="p">)</span>
        
        <span class="n">node_color</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">node_color</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">node_color</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="n">xu</span><span class="o">.</span><span class="n">draw_tree</span><span class="p">(</span>
        <span class="n">G</span><span class="p">,</span>
        <span class="n">draw_type</span> <span class="o">=</span> <span class="n">draw_type</span><span class="p">,</span><span class="c1">#&quot;twopi&quot; (the circular), &quot;circo&quot; (makes square like)</span>
        <span class="n">node_size</span><span class="o">=</span><span class="n">node_size</span><span class="p">,</span>
        <span class="n">font_size</span> <span class="o">=</span> <span class="n">font_size</span><span class="p">,</span>
        <span class="n">font_color</span> <span class="o">=</span> <span class="n">font_color</span><span class="p">,</span>
        <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">,</span>
        <span class="n">node_color</span><span class="o">=</span><span class="n">node_color</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    
<span class="n">skeletal_length_min_starter_branches_global</span> <span class="o">=</span> <span class="mi">700</span>
<div class="viewcode-block" id="small_starter_branches"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.small_starter_branches">[docs]</a><span class="k">def</span> <span class="nf">small_starter_branches</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">skeletal_length_min</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">soma_node_name</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To identify starting nodes may want to remove</span>

<span class="sd">    Pseuodocde: </span>
<span class="sd">    1) Look for those with small lengths</span>
<span class="sd">    2) Look for those that neighbor the soma</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">skeletal_length_min</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">skeletal_length_min</span> <span class="o">=</span> <span class="n">skeletal_length_min_starter_branches_global</span>

    <span class="k">if</span> <span class="n">soma_node_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">soma_node_name</span><span class="o">=</span> <span class="n">soma_node_name_global</span>
        
    <span class="k">if</span> <span class="n">nxu</span><span class="o">.</span><span class="n">soma_only_graph</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="n">small_nodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">nodes_from_node_query</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;(skeletal_length &lt; </span><span class="si">{</span><span class="n">skeletal_length_min</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;small_nodes = </span><span class="si">{</span><span class="n">small_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">small_soma_neighbors</span><span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">small_nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">soma_partners</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">downstream_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">soma_node_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;soma_partners= </span><span class="si">{</span><span class="n">soma_partners</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">small_soma_neighbors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">small_nodes</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">soma_partners</span><span class="p">)))</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;small_soma_neighbors= </span><span class="si">{</span><span class="n">small_soma_neighbors</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">small_soma_neighbors</span></div>



<div class="viewcode-block" id="remove_node"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.remove_node">[docs]</a><span class="k">def</span> <span class="nf">remove_node</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">node</span><span class="p">,</span>
    <span class="n">inplace</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">maintain_skeleton_connectivity</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">remove_all_downstream_nodes</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To remove a node from the graph</span>
<span class="sd">    and to reconnect the downstream children</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get any downstream nodes </span>
<span class="sd">        a. (if none then just delete and return)</span>
<span class="sd">    2) For each downstream node:</span>

<span class="sd">    Attributes that need to be changed: </span>

<span class="sd">    # if ask to alter skeleton</span>
<span class="sd">    endpoint_upstream --&gt; parent endpoint_upstream</span>
<span class="sd">    skeleton_coordinates --&gt; add parent endpoint_upstream</span>

<span class="sd">    #the soma information</span>
<span class="sd">    &#39;soma_start_vec&#39;: array([-0.375219  , -0.91207943, -0.16529313]),</span>
<span class="sd">     &#39;soma_start_angle&#39;: 24.21}</span>
<span class="sd">     </span>
<span class="sd">     </span>
<span class="sd">    Ez: </span>
<span class="sd">    new_G = nxu.remove_node(</span>
<span class="sd">    G,</span>
<span class="sd">    node=&quot;L0_22&quot;,</span>
<span class="sd">    inplace = False,</span>
<span class="sd">    verbose = True,</span>
<span class="sd">    maintain_skeleton_connectivity = True,</span>
<span class="sd">        )</span>

<span class="sd">    nxu.soma_connected_nodes(new_G)</span>
<span class="sd">    new_G.nodes[&quot;L0_19&quot;][&quot;skeleton_data&quot;],new_G.nodes[&quot;L0_20&quot;][&quot;skeleton_data&quot;]</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Ex 2: Deleting all downstream nodes</span>
<span class="sd">    nodes = [&quot;L1_10&quot;,&quot;L1_2&quot;,&quot;L1_8&quot;,&quot;L0_20&quot;]</span>
<span class="sd">    G_del = nxu.remove_node(</span>
<span class="sd">        G,</span>
<span class="sd">        node=nodes,</span>
<span class="sd">        inplace=False,</span>
<span class="sd">        verbose = True,</span>
<span class="sd">        remove_all_downstream_nodes = True</span>
<span class="sd">    )</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

    <span class="n">nodes</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">convert_to_array_like</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--Working on removing node </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">G</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;node </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2"> wasn&#39;t in graph nodes so continuing&quot;</span><span class="p">)</span>
            <span class="k">continue</span>
            
        <span class="n">downstream_nodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">downstream_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;downstream_nodes = </span><span class="si">{</span><span class="n">downstream_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">downstream_nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">remove_all_downstream_nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nxu</span><span class="o">.</span><span class="n">soma_connected_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
                <span class="n">soma_vals</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;soma_start_vec&quot;</span><span class="p">,</span><span class="s2">&quot;soma_start_angle&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Adding </span><span class="si">{</span><span class="n">soma_vals</span><span class="si">}</span><span class="s2"> to the downstream nodes&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">soma_vals</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">downstream_nodes</span><span class="p">:</span>
                        <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">att</span><span class="p">]</span>  <span class="o">=</span>  <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">att</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">maintain_skeleton_connectivity</span><span class="p">:</span>
                <span class="n">endpoint_upstream</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;endpoint_upstream&quot;</span><span class="p">]</span>
                <span class="n">width_upstream</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;width_new&quot;</span><span class="p">][</span><span class="s2">&quot;no_spine_median_mesh_center&quot;</span><span class="p">]</span>
                
                <span class="n">skeletal_length_upstream</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;skeletal_length&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Adding endpoint_upstream </span><span class="si">{</span><span class="n">endpoint_upstream</span><span class="si">}</span><span class="s2"> to the downstream nodes skeleton&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">downstream_nodes</span><span class="p">:</span>
                    <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;endpoint_upstream&quot;</span><span class="p">]</span>  <span class="o">=</span> <span class="n">endpoint_upstream</span>
                    <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;skeleton_data&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([[</span><span class="n">endpoint_upstream</span><span class="p">],</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;skeleton_data&quot;</span><span class="p">]])</span>
                    <span class="n">width_upstream_curr</span> <span class="o">=</span> <span class="n">width_upstream</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,(</span><span class="n">k</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;width_data&quot;</span><span class="p">]):</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">width_upstream</span><span class="p">):</span>
                            <span class="n">width_upstream_curr</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;width_data&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;width&quot;</span><span class="p">]</span>
                        
                        <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;width_data&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;upstream_dist&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;width_data&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;upstream_dist&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">skeletal_length_upstream</span>
                    <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;width_data&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">upstream_dist</span><span class="o">=</span><span class="n">skeletal_length_upstream</span><span class="p">,</span>
                                                     <span class="n">width</span> <span class="o">=</span> <span class="n">width_upstream_curr</span><span class="p">)]</span> <span class="o">+</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;width_data&quot;</span><span class="p">]</span>
                    
        <span class="k">if</span> <span class="ow">not</span> <span class="n">remove_all_downstream_nodes</span><span class="p">:</span>
            <span class="n">xu</span><span class="o">.</span><span class="n">remove_node_reattach_children_di</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">,</span><span class="n">inplace</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">all_downstream_nodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">all_downstream_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">)</span>
            <span class="n">total_nodes_to_delete</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="p">]</span> 
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_downstream_nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">total_nodes_to_delete</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">all_downstream_nodes</span><span class="p">)</span>
                
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Removing all downstream nodes along with node </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">total_nodes_to_delete</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">G</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">total_nodes_to_delete</span><span class="p">)</span>
            
    <span class="k">return</span> <span class="n">G</span></div>
    

<div class="viewcode-block" id="remove_small_starter_branches"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.remove_small_starter_branches">[docs]</a><span class="k">def</span> <span class="nf">remove_small_starter_branches</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">skeletal_length_min</span><span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">inplace</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">maintain_skeleton_connectivity</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">loop_until_fail</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To remove small starter branches from </span>
<span class="sd">    the graph</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    nxu.remove_small_starter_branches(G,verbose = True)</span>
<span class="sd">    </span>
<span class="sd">    Ex 2:</span>
<span class="sd">    new_G = nxu.remove_small_starter_branches(</span>
<span class="sd">        G,</span>
<span class="sd">        skeletal_length_min = 100000000000,</span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">sm_st_branches</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">small_starter_branches</span><span class="p">(</span>
            <span class="n">G</span><span class="p">,</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
            <span class="n">skeletal_length_min</span> <span class="o">=</span> <span class="n">skeletal_length_min</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Soma Starter Branches = </span><span class="si">{</span><span class="n">sm_st_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1">#     for s_b in sm_st_branches:</span>
    <span class="c1"># #         if verbose:</span>
    <span class="c1"># #             print(f&quot;Removing {s_b}&quot;)</span>
        <span class="n">nxu</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span>
            <span class="n">G</span><span class="p">,</span>
            <span class="n">sm_st_branches</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
            <span class="n">inplace</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">maintain_skeleton_connectivity</span><span class="o">=</span><span class="n">maintain_skeleton_connectivity</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">loop_until_fail</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">sm_st_branches</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">continue</span>

    <span class="k">return</span> <span class="n">G</span></div>

<span class="n">filter_small_starter_branches</span> <span class="o">=</span> <span class="n">remove_small_starter_branches</span> 

<div class="viewcode-block" id="soma_radius"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.soma_radius">[docs]</a><span class="k">def</span> <span class="nf">soma_radius</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">stat</span> <span class="o">=</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find the [stat] distance of the soma from the neighbors</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">soma_neighbors</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">downstream_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">soma_node_name_global</span><span class="p">)</span>
    <span class="n">s_center</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">soma_node_name_global</span><span class="p">][</span><span class="s2">&quot;mesh_center&quot;</span><span class="p">]</span>
    <span class="n">endpoints_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">([</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;endpoint_upstream&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">s_center</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">soma_neighbors</span><span class="p">],</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">stat_dist</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span><span class="n">stat</span><span class="p">)(</span><span class="n">endpoints_dist</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;soma_neighbors = </span><span class="si">{</span><span class="n">soma_neighbors</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;endpoints_dist = </span><span class="si">{</span><span class="n">endpoints_dist</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">stat</span><span class="si">}</span><span class="s2"> dist = </span><span class="si">{</span><span class="n">stat_dist</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">stat_dist</span></div>
    
    
<span class="c1"># --------------- For exporting graph as differnt file types -------------</span>

<span class="n">compartment_index_swc_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">dendrite</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">soma</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">axon</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">basal</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
        <span class="n">apical</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
        <span class="n">apical_tuft</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
        <span class="n">oblique</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
        <span class="n">apical_shaft</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
        <span class="n">custom</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">undefined</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
        <span class="n">glia</span> <span class="o">=</span> <span class="mi">7</span>
    <span class="p">)</span>

<div class="viewcode-block" id="export_swc_dicts"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.export_swc_dicts">[docs]</a><span class="k">def</span> <span class="nf">export_swc_dicts</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">use_skeletal_coordinates</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">soma_node_name</span> <span class="o">=</span> <span class="n">soma_node_name_global</span><span class="p">,</span>
    <span class="n">default_skeleton_pt</span> <span class="o">=</span> <span class="s2">&quot;mesh_center&quot;</span><span class="p">,</span>
    <span class="n">default_compartment</span> <span class="o">=</span> <span class="s2">&quot;basal&quot;</span><span class="p">,</span><span class="c1">#&quot;undefined&quot;,</span>
    <span class="n">center_on_soma</span><span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">coordinate_divisor</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
    <span class="n">width_divisor</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_df</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To convert a Graph Neuron Object</span>
<span class="sd">    into a SWC file dict objects by creating dictionaries of all of the points</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    In a depth first search manner of searching</span>
<span class="sd">    For each node: </span>
<span class="sd">        1) get the skeleton points</span>
<span class="sd">        2) Get the compartment</span>
<span class="sd">        3) Get the parent idx</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">soma_node_name</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
        <span class="n">center_point</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">soma_node_name</span><span class="p">][</span><span class="s2">&quot;mesh_center&quot;</span><span class="p">]</span>
        <span class="n">source_node</span> <span class="o">=</span> <span class="n">soma_node_name</span>
        <span class="n">node_order</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dfs_preorder_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">source</span> <span class="o">=</span> <span class="n">soma_node_name</span><span class="p">)</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="n">center_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;mesh_center&quot;</span><span class="p">]</span>
                               <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">source_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">most_upstream_node</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="n">node_order</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dfs_preorder_nodes</span><span class="p">(</span>
            <span class="n">G</span><span class="p">,</span><span class="n">source</span> <span class="o">=</span> <span class="n">source_node</span><span class="p">)</span>

    
    <span class="n">node_to_index_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">swc_dicts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">node_order</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">---Working on </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">node_to_index_map</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">use_skeletal_coordinates</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">soma_node_name</span><span class="p">:</span>
            <span class="n">skeleton_pts</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;skeleton_data&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">skeleton_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">default_skeleton_pt</span><span class="p">]])</span>

        <span class="n">curr_compartment</span>  <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;compartment&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">source_node</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">soma_node_name</span><span class="p">:</span> 
                <span class="n">curr_compartment</span> <span class="o">=</span> <span class="s2">&quot;soma&quot;</span>
            <span class="n">parent_idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">parent_name</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">parent_node</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
            <span class="n">parent_idx</span> <span class="o">=</span> <span class="n">node_to_index_map</span><span class="p">[</span><span class="n">parent_name</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">soma_node_name</span><span class="p">:</span>
            <span class="n">width_points</span> <span class="o">=</span> <span class="p">[</span><span class="n">nxu</span><span class="o">.</span><span class="n">soma_radius</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">use_skeletal_coordinates</span><span class="p">:</span>
                <span class="n">width_points</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;width&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;width_data&quot;</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">width_points</span> <span class="o">=</span> <span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;width_new&quot;</span><span class="p">][</span><span class="s2">&quot;no_spine_median_mesh_center&quot;</span><span class="p">]]</span>

        
        <span class="k">if</span> <span class="n">curr_compartment</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">curr_compartment</span> <span class="o">=</span> <span class="n">default_compartment</span>
            
<span class="c1">#         if curr_compartment == &quot;dendrite&quot;:</span>
<span class="c1">#             curr_compartment = default_compartment</span>

        <span class="k">if</span> <span class="n">center_on_soma</span><span class="p">:</span>
            <span class="n">skeleton_pts</span> <span class="o">=</span> <span class="n">skeleton_pts</span> <span class="o">-</span> <span class="n">center_point</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;skeleton_pts = </span><span class="si">{</span><span class="n">skeleton_pts</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;parent_idx= </span><span class="si">{</span><span class="n">parent_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_compartment= </span><span class="si">{</span><span class="n">curr_compartment</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">coord</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">skeleton_pts</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">curr_parent_idx</span> <span class="o">=</span> <span class="n">parent_idx</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">curr_parent_idx</span> <span class="o">=</span> <span class="n">index</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="n">curr_dict</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;n&quot;</span><span class="p">:</span><span class="n">index</span><span class="p">,</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span><span class="n">compartment_index_swc_map</span><span class="p">[</span><span class="n">curr_compartment</span><span class="p">],</span>
                <span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">coordinate_divisor</span><span class="p">,</span>
                <span class="s2">&quot;y&quot;</span><span class="p">:</span><span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">coordinate_divisor</span><span class="p">,</span>
                <span class="s2">&quot;z&quot;</span><span class="p">:</span><span class="n">coord</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="n">coordinate_divisor</span><span class="p">,</span>
                <span class="s2">&quot;radius&quot;</span><span class="p">:</span> <span class="n">width_points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">width_divisor</span><span class="p">,</span>
                <span class="s2">&quot;parent&quot;</span><span class="p">:</span><span class="n">curr_parent_idx</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="n">node_to_index_map</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

            <span class="n">swc_dicts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_dict</span><span class="p">)</span> 
    
    <span class="k">if</span> <span class="n">return_df</span><span class="p">:</span>
        <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_records</span><span class="p">(</span><span class="n">swc_dicts</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">swc_dicts</span></div>

<div class="viewcode-block" id="export_swc_df"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.export_swc_df">[docs]</a><span class="k">def</span> <span class="nf">export_swc_df</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_records</span><span class="p">(</span><span class="n">export_swc_dicts</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">return_df</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">))</span></div>


<div class="viewcode-block" id="export_swc_file"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.export_swc_file">[docs]</a><span class="k">def</span> <span class="nf">export_swc_file</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">filename_append</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">directory</span><span class="o">=</span><span class="s2">&quot;./&quot;</span><span class="p">,</span>
    <span class="n">filepath</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">header</span> <span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Create a SWC file from </span>
<span class="sd">    graph object</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">swc_dicts</span><span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">export_swc_dicts</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;seg_</span><span class="si">{</span><span class="n">G</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;segment_id&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">_split_</span><span class="si">{</span><span class="n">G</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;split_index&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">_nucleus_</span><span class="si">{</span><span class="n">G</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;nucleus_id&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">if</span> <span class="n">filename_append</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">filename_append</span><span class="si">}</span><span class="s2">&quot;</span>
        
    <span class="k">if</span> <span class="n">filename</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span> <span class="o">!=</span> <span class="s2">&quot;.swc&quot;</span><span class="p">:</span>
        <span class="n">filename</span> <span class="o">+=</span> <span class="s2">&quot;.swc&quot;</span>
        
    <span class="k">return</span> <span class="n">fileu</span><span class="o">.</span><span class="n">file_from_dicts</span><span class="p">(</span>
        <span class="n">swc_dicts</span><span class="p">,</span>
        <span class="n">header</span> <span class="o">=</span> <span class="n">header</span><span class="p">,</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span><span class="p">,</span>
        <span class="n">directory</span> <span class="o">=</span> <span class="n">directory</span><span class="p">,</span>
        <span class="n">filepath</span> <span class="o">=</span> <span class="n">filepath</span><span class="p">,</span>
        <span class="n">seperation_character</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
    <span class="p">)</span></div>
    



<span class="c1"># -------------- computing morphology metrics using morphopy -----</span>

<div class="viewcode-block" id="swc_df"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.swc_df">[docs]</a><span class="k">def</span> <span class="nf">swc_df</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">flip_z</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">swc</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">export_swc_df</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="n">swc_df</span> <span class="o">=</span> <span class="n">mpu</span><span class="o">.</span><span class="n">swc_rotated_resampled</span><span class="p">(</span><span class="n">swc</span><span class="p">,</span><span class="n">resample</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">flip_z</span> <span class="o">=</span> <span class="n">flip_z</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">swc_df</span></div>

<div class="viewcode-block" id="morphometrics"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.morphometrics">[docs]</a><span class="k">def</span> <span class="nf">morphometrics</span><span class="p">(</span>
    <span class="n">G</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">swc</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">apply_basal_dendrite_swap</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
    
    <span class="k">if</span> <span class="n">swc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">swc</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">swc_df</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">apply_basal_dendrite_swap</span><span class="p">:</span>
        <span class="c1"># --- fixed so dendrite compartment will be changed to basal and recognized as dendrite ---</span>
        <span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">pandas_utils</span> <span class="k">as</span> <span class="n">pu</span>
        <span class="k">def</span> <span class="nf">basal_rename</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">compartment_index_swc_map</span><span class="p">[</span><span class="s2">&quot;dendrite&quot;</span><span class="p">]:</span>
                <span class="k">return</span> <span class="n">compartment_index_swc_map</span><span class="p">[</span><span class="s2">&quot;basal&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span>

        <span class="n">swc</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pu</span><span class="o">.</span><span class="n">new_column_from_row_function</span><span class="p">(</span><span class="n">swc</span><span class="p">,</span><span class="n">basal_rename</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
        <span class="c1">#return swc</span>
    
    <span class="c1">#swc_df = mpu.swc_rotated_resampled(swc,resample=False,flip_z = True)</span>
        
    <span class="k">return</span> <span class="n">mpu</span><span class="o">.</span><span class="n">morphometrics</span><span class="p">(</span><span class="n">swc</span><span class="o">=</span><span class="n">swc</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<span class="c1"># ------------ for querying neuron graphs ----</span>
<div class="viewcode-block" id="axon_dendrite_nodes"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.axon_dendrite_nodes">[docs]</a><span class="k">def</span> <span class="nf">axon_dendrite_nodes</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">compartment</span><span class="o">=</span><span class="s2">&quot;axon&quot;</span><span class="p">,</span>
    <span class="n">return_node_df</span><span class="o">=</span><span class="kc">False</span><span class="p">,):</span>
    
    <span class="n">node_df</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">node_df</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">node_df</span> <span class="o">=</span> <span class="n">node_df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;axon_compartment==&#39;</span><span class="si">{</span><span class="n">compartment</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">pass</span> 
    
    <span class="k">if</span> <span class="n">return_node_df</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">node_df</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">node_df</span><span class="p">[</span><span class="n">node_label</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span></div>
    
<div class="viewcode-block" id="axon_nodes"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.axon_nodes">[docs]</a><span class="k">def</span> <span class="nf">axon_nodes</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">return_node_df</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="n">nxu</span><span class="o">.</span><span class="n">axon_dendrite_nodes</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">compartment</span><span class="o">=</span><span class="s2">&quot;axon&quot;</span><span class="p">,</span>
    <span class="n">return_node_df</span><span class="o">=</span><span class="n">return_node_df</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="dendrite_nodes"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.dendrite_nodes">[docs]</a><span class="k">def</span> <span class="nf">dendrite_nodes</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">return_node_df</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="n">nxu</span><span class="o">.</span><span class="n">axon_dendrite_nodes</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">compartment</span><span class="o">=</span><span class="s2">&quot;dendrite&quot;</span><span class="p">,</span>
    <span class="n">return_node_df</span><span class="o">=</span><span class="n">return_node_df</span><span class="p">,)</span></div>

<div class="viewcode-block" id="axon_dendrite_subgraph"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.axon_dendrite_subgraph">[docs]</a><span class="k">def</span> <span class="nf">axon_dendrite_subgraph</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">compartment</span><span class="p">,</span>
    <span class="n">include_soma</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">remove_node_method</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
    
    <span class="n">compartment_nodes</span> <span class="o">=</span>  <span class="nb">list</span><span class="p">(</span><span class="n">axon_dendrite_nodes</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">compartment</span><span class="o">=</span><span class="n">compartment</span><span class="p">,</span>
    <span class="n">return_node_df</span><span class="o">=</span><span class="kc">False</span><span class="p">,))</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;compartment_nodes = </span><span class="si">{</span><span class="n">compartment_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">include_soma</span><span class="p">:</span>
        <span class="n">compartment_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nxu</span><span class="o">.</span><span class="n">soma_node_name_global</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">remove_node_method</span><span class="p">:</span>
        <span class="n">nodes_to_remove</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()),</span><span class="n">compartment_nodes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">nxu</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span>
            <span class="n">G</span><span class="p">,</span>
            <span class="n">nodes_to_remove</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">compartment_nodes</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>
        
<div class="viewcode-block" id="axon_subgraph"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.axon_subgraph">[docs]</a><span class="k">def</span> <span class="nf">axon_subgraph</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">include_soma</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
    <span class="k">return</span> <span class="n">nxu</span><span class="o">.</span><span class="n">axon_dendrite_subgraph</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">compartment</span><span class="o">=</span><span class="s2">&quot;axon&quot;</span><span class="p">,</span>
    <span class="n">include_soma</span> <span class="o">=</span> <span class="n">include_soma</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="dendrite_subgraph"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.dendrite_subgraph">[docs]</a><span class="k">def</span> <span class="nf">dendrite_subgraph</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">include_soma</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
    <span class="k">return</span> <span class="n">nxu</span><span class="o">.</span><span class="n">axon_dendrite_subgraph</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">compartment</span><span class="o">=</span><span class="s2">&quot;dendrite&quot;</span><span class="p">,</span>
    <span class="n">include_soma</span> <span class="o">=</span> <span class="n">include_soma</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="plot"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.plot">[docs]</a><span class="k">def</span> <span class="nf">plot</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">xlim</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">ylim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">zlim</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    
    <span class="c1">#st = time.time()</span>
    <span class="n">swc_df</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">swc_df</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="n">ntree_obj</span> <span class="o">=</span> <span class="n">mpu</span><span class="o">.</span><span class="n">ntree_obj_from_swc</span><span class="p">(</span><span class="n">swc</span><span class="o">=</span><span class="n">swc_df</span><span class="p">)</span>
    <span class="n">mpu</span><span class="o">.</span><span class="n">plot_ntree</span><span class="p">(</span>
        <span class="n">ntree_obj</span><span class="p">,</span>
        <span class="n">xlim</span> <span class="o">=</span> <span class="n">xlim</span><span class="p">,</span>
        <span class="n">ylim</span><span class="o">=</span><span class="n">ylim</span><span class="p">,</span>
        <span class="n">zlim</span> <span class="o">=</span> <span class="n">zlim</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<span class="c1"># --------- mapping errors to nodes ----------</span>
<div class="viewcode-block" id="limb_from_node_name"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.limb_from_node_name">[docs]</a><span class="k">def</span> <span class="nf">limb_from_node_name</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">name</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)])</span></div>

<div class="viewcode-block" id="branch_from_node_name"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.branch_from_node_name">[docs]</a><span class="k">def</span> <span class="nf">branch_from_node_name</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="n">name</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span></div>

<div class="viewcode-block" id="limb_branch_nodes"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.limb_branch_nodes">[docs]</a><span class="k">def</span> <span class="nf">limb_branch_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="s2">&quot;S&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">k</span><span class="p">]</span></div>

<div class="viewcode-block" id="limb_branch_subgraph"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.limb_branch_subgraph">[docs]</a><span class="k">def</span> <span class="nf">limb_branch_subgraph</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">nxu</span><span class="o">.</span><span class="n">limb_branch_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">))</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>

<div class="viewcode-block" id="all_limb_idxs_in_G"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.all_limb_idxs_in_G">[docs]</a><span class="k">def</span> <span class="nf">all_limb_idxs_in_G</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="n">nxu</span><span class="o">.</span><span class="n">limb_from_node_name</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">limb_branch_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">)]))</span></div>

<div class="viewcode-block" id="all_limb_graphs"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.all_limb_graphs">[docs]</a><span class="k">def</span> <span class="nf">all_limb_graphs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">return_idxs</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="n">limb_idxs</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">all_limb_idxs_in_G</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="n">return_graphs</span> <span class="o">=</span> <span class="p">[</span><span class="n">limb_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">limb_idxs</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">return_idxs</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">return_graphs</span><span class="p">,</span><span class="n">limb_idxs</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">return_graphs</span></div>
    
<div class="viewcode-block" id="all_limb_graphs_off_soma"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.all_limb_graphs_off_soma">[docs]</a><span class="k">def</span> <span class="nf">all_limb_graphs_off_soma</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="n">components</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span>
        <span class="n">xu</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">(</span><span class="n">G</span><span class="p">,[</span><span class="n">nxu</span><span class="o">.</span><span class="n">soma_node_name_global</span><span class="p">]</span>
                            <span class="p">)</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;components = </span><span class="si">{</span><span class="n">components</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">return_graphs</span> <span class="o">=</span> <span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">subgraph_nodes</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                     <span class="k">for</span> <span class="n">subgraph_nodes</span> <span class="ow">in</span> <span class="n">components</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of limb subgraphs off soma = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">return_graphs</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">return_graphs</span></div>
    
    

<div class="viewcode-block" id="limb_graph"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.limb_graph">[docs]</a><span class="k">def</span> <span class="nf">limb_graph</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">limb_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">most_upstream_node</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">branches_idx</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To return a graph of a certain limb</span>
<span class="sd">    </span>
<span class="sd">    Ex: nxu.limb_graph(G_ax,limb_idx = 3,verbose = True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">limb_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using the limb_idx method&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">limb_idx</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">limb_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">limb_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

        <span class="k">if</span> <span class="n">limb_idx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Returning whole graph&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">G</span>

        <span class="n">subgraph_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">nxu</span><span class="o">.</span><span class="n">limb_branch_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
                         <span class="k">if</span> <span class="n">nxu</span><span class="o">.</span><span class="n">limb_from_node_name</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">==</span> <span class="n">limb_idx</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">branches_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">subgraph_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">subgraph_nodes</span>
                             <span class="k">if</span> <span class="n">nxu</span><span class="o">.</span><span class="n">branch_from_node_name</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="ow">in</span> <span class="n">branches_idx</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;subgraph_nodes after branch restriction: </span><span class="si">{</span><span class="n">subgraph_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">most_upstream_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using the most upstream method&quot;</span><span class="p">)</span>
        <span class="n">subgraph_nodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">all_downstream_nodes</span><span class="p">(</span>
            <span class="n">G</span><span class="p">,</span>
            <span class="n">most_upstream_node</span><span class="p">,</span>
            <span class="n">include_self</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;subgraph_nodes after restriction: </span><span class="si">{</span><span class="n">subgraph_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">subgraph_nodes</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>


<div class="viewcode-block" id="node_match_by_dict"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.node_match_by_dict">[docs]</a><span class="k">def</span> <span class="nf">node_match_by_dict</span><span class="p">(</span>
    <span class="n">dict1</span><span class="p">,</span>
    <span class="n">dict2</span><span class="p">,</span>
    <span class="n">attributes</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;endpoint_upstream&quot;</span><span class="p">,</span>
        <span class="c1">#&quot;endpoint_downstream&quot;,</span>
        <span class="s2">&quot;skeleton_vector_upstream&quot;</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To compare whether two</span>
<span class="sd">    nodes are the same or not</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    node_match_by_dict(</span>
<span class="sd">    G_ax.nodes[&quot;L0_0&quot;],</span>
<span class="sd">    G_ax.nodes[&quot;L0_1&quot;],</span>
<span class="sd">    verbose = True</span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">match_flag</span> <span class="o">=</span> <span class="kc">True</span>
    
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">:</span>
        <span class="n">val1</span> <span class="o">=</span> <span class="n">dict1</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
        <span class="n">val2</span> <span class="o">=</span> <span class="n">dict2</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="s2">&quot;array&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">val1</span><span class="p">)):</span>
            <span class="n">comp_result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">val1</span><span class="p">,</span><span class="n">val2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">val1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
            <span class="n">comp_result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="n">k1</span><span class="o">==</span><span class="n">k2</span> <span class="k">for</span> <span class="n">k1</span><span class="p">,</span><span class="n">k2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">val1</span><span class="p">,</span><span class="n">val2</span><span class="p">)])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">comp_result</span>  <span class="o">=</span> <span class="n">val1</span><span class="o">==</span><span class="n">val2</span>
            
        <span class="k">if</span> <span class="n">comp_result</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">match_flag</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Did not have equal </span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">val1</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">val2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
    
    <span class="k">return</span> <span class="n">match_flag</span></div>


<div class="viewcode-block" id="node_map"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.node_map">[docs]</a><span class="k">def</span> <span class="nf">node_map</span><span class="p">(</span>
    <span class="n">G_source</span><span class="p">,</span>
    <span class="n">G_target</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find the matches of all the nodes</span>
<span class="sd">    of one graph to another:</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    For each node in the source graph</span>
<span class="sd">        Iterate through the target graph nodes</span>
<span class="sd">            Compare the certain properties, and if all match then assign as the correct mapping</span>
<span class="sd">            </span>
<span class="sd">            </span>
<span class="sd">    nxu.node_map(</span>
<span class="sd">        G_source = G_ax,</span>
<span class="sd">        G_target = G_proof,</span>
<span class="sd">        verbose = True</span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">source_to_target_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nxu</span><span class="o">.</span><span class="n">limb_branch_nodes</span><span class="p">(</span><span class="n">G_source</span><span class="p">):</span>

        <span class="n">limb_idx</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">limb_from_node_name</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">matching_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">nt</span> <span class="ow">in</span> <span class="n">nxu</span><span class="o">.</span><span class="n">limb_branch_nodes</span><span class="p">(</span><span class="n">G_target</span><span class="p">):</span>

            <span class="n">limb_idx_t</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">limb_from_node_name</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">limb_idx</span> <span class="o">!=</span> <span class="n">limb_idx_t</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">match_result</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">node_match_by_dict</span><span class="p">(</span>
                <span class="n">G_source</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
                <span class="n">G_target</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">nt</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">match_result</span><span class="p">:</span>
                <span class="n">matching_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Node </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> --&gt; </span><span class="si">{</span><span class="n">matching_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matching_nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;More than 1 match&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matching_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">source_to_target_map</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">continue</span>

        <span class="n">match</span> <span class="o">=</span> <span class="n">matching_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">nxu</span><span class="o">.</span><span class="n">limb_from_node_name</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">limb_from_node_name</span><span class="p">(</span><span class="n">match</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Not on same limb&quot;</span><span class="p">)</span>

        <span class="n">source_to_target_map</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">match</span>

    <span class="c1">#check to see if unique</span>
    <span class="n">final_matches</span> <span class="o">=</span> <span class="nb">list</span><span class="p">([</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">source_to_target_map</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                          <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">final_matches</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">final_matches</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Some repeats&quot;</span><span class="p">)</span>
            
    <span class="k">return</span> <span class="n">source_to_target_map</span></div>
            
<div class="viewcode-block" id="nodes_without_match"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.nodes_without_match">[docs]</a><span class="k">def</span> <span class="nf">nodes_without_match</span><span class="p">(</span>
    <span class="n">G_source</span><span class="p">,</span>
    <span class="n">G_target</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    
    <span class="n">curr_map</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">node_map</span><span class="p">(</span>
        <span class="n">G_source</span><span class="p">,</span>
        <span class="n">G_target</span><span class="p">)</span>
    
    <span class="n">no_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">curr_map</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">])</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Nodes with no match = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">no_map</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">no_map</span></div>

<div class="viewcode-block" id="skeleton_from_node"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.skeleton_from_node">[docs]</a><span class="k">def</span> <span class="nf">skeleton_from_node</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ex: nxu.skeleton_from_node(G_obj,n = &quot;L0_16&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">skeleton_points</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;skeleton_data&quot;</span><span class="p">]</span>
    <span class="n">sk_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span>
        <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">skeleton_points</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">skeleton_points</span><span class="p">))])</span><span class="o">.</span><span class="n">T</span>
    <span class="k">return</span> <span class="n">skeleton_points</span><span class="p">[</span><span class="n">sk_idx</span><span class="p">]</span></div>
    
<div class="viewcode-block" id="skeleton_coordinates_from_G"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.skeleton_coordinates_from_G">[docs]</a><span class="k">def</span> <span class="nf">skeleton_coordinates_from_G</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">include_upstream_node</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_node_names</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To output the skeleton points of a graph</span>
<span class="sd">    and the node names those skeleton points came from</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    sk_pts,sk_names = nxu.skeleton_coordinates_from_G(</span>
<span class="sd">        G_ax,</span>
<span class="sd">    return_node_names=True,</span>
<span class="sd">    verbose = True)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">total_skeleton_points</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">total_node_names</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nxu</span><span class="o">.</span><span class="n">limb_branch_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
        <span class="n">skeleton_points</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;skeleton_data&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">include_upstream_node</span><span class="p">:</span>
            <span class="n">upstream_coordinate</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;endpoint_upstream&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">skeleton_points</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">setdiff2d</span><span class="p">(</span><span class="n">skeleton_points</span><span class="p">,</span><span class="n">upstream_coordinate</span><span class="p">)</span>

        <span class="n">node_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">n</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">skeleton_points</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Node </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> has </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">skeleton_points</span><span class="p">)</span><span class="si">}</span><span class="s2"> skeleton points&quot;</span><span class="p">)</span>

        <span class="n">total_skeleton_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">skeleton_points</span><span class="p">)</span>
        <span class="n">total_node_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_names</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">total_skeleton_points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">total_skeleton_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">total_skeleton_points</span><span class="p">)</span>
        <span class="n">total_node_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">total_node_names</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">total_skeleton_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="n">total_node_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total skeleton points = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">total_skeleton_points</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_node_names</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">total_skeleton_points</span><span class="p">,</span><span class="n">total_node_names</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">total_skeleton_points</span></div>
    
    

<div class="viewcode-block" id="split_location_node_map_df"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.split_location_node_map_df">[docs]</a><span class="k">def</span> <span class="nf">split_location_node_map_df</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">split_locations</span><span class="p">,</span>
    <span class="n">G_target</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">nodelist</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">distance_max</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span>
    <span class="n">error_if_no_one_match</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">error_on_non_unique_node_names</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose_loop</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Want to map split locaitons to the nodes that</span>
<span class="sd">    were cut off due to proofreading with what rule was used to cut off</span>

<span class="sd">    Things can leverage:</span>
<span class="sd">        The limb name</span>
<span class="sd">        Nodes that shouldn&#39;t be mapped</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    Iterate through all filters and limbs to work</span>
<span class="sd">    with the split locations and possible nodes to match with</span>



<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">split_info</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">G_target</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">nodelist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nodelist</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">nodes_without_match</span><span class="p">(</span>
            <span class="n">G_source</span> <span class="o">=</span> <span class="n">G</span><span class="p">,</span>
            <span class="n">G_target</span><span class="o">=</span><span class="n">G_target</span><span class="p">,</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span> <span class="p">)</span>

    <span class="k">if</span> <span class="n">nodelist</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> 
        <span class="n">G_search</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">nodelist</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">G_search</span> <span class="o">=</span> <span class="n">G</span>

    <span class="n">split_counter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">filter_name</span><span class="p">,</span><span class="n">filter_splits</span> <span class="ow">in</span> <span class="n">split_locations</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">filter_splits</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="n">filter_splits</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;L-1&quot;</span><span class="p">:</span><span class="n">filter_splits</span><span class="p">}</span>

        <span class="k">for</span> <span class="n">limb_name</span><span class="p">,</span><span class="n">split_loc</span> <span class="ow">in</span> <span class="n">filter_splits</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">G_limb</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">limb_graph</span><span class="p">(</span><span class="n">G_search</span><span class="p">,</span><span class="n">limb_name</span><span class="p">)</span>

<span class="c1">#             sk_pts,sk_names = nxu.skeleton_coordinates_from_G(</span>
<span class="c1">#                 G_limb,</span>
<span class="c1">#                 return_node_names=True,</span>
<span class="c1">#                 verbose = False)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">G_limb</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Empty graph&quot;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">split_loc</span><span class="p">):</span>
                
                <span class="n">local_split</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">limb_split_idx</span> <span class="o">=</span> <span class="n">i</span><span class="p">,</span>
                                   <span class="n">limb_name</span> <span class="o">=</span> <span class="n">limb_name</span><span class="p">,</span>
                                   <span class="n">coord</span> <span class="o">=</span> <span class="n">s</span><span class="p">,</span>
                                  <span class="n">filter_name</span> <span class="o">=</span> <span class="n">filter_name</span><span class="p">)</span>
<span class="w">                </span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                4/13: Want to determine the node that has the lowest average distance</span>
<span class="sd">                </span>
<span class="sd">                Pseudocode:</span>
<span class="sd">                1) Iterate through all of the nodes</span>
<span class="sd">                2) Build a KDTree on their skeleton points</span>
<span class="sd">                3) Find the average distance</span>
<span class="sd">                4) Add to name and distance to list to find min later</span>
<span class="sd">                </span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="n">sk_names</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">dist_from_split</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nxu</span><span class="o">.</span><span class="n">limb_branch_nodes</span><span class="p">(</span><span class="n">G_limb</span><span class="p">):</span>
<span class="w">                    </span><span class="sd">&#39;&#39;&#39;    </span>
<span class="sd">                    dist_from_split = np.linalg.norm(sk_pts - s,axis = 1)</span>
<span class="sd">                    &#39;&#39;&#39;</span>
                    <span class="n">n_kd</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">G_limb</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;skeleton_data&quot;</span><span class="p">])</span>
                    <span class="n">dist</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">n_kd</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
                    <span class="n">sk_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                    <span class="n">dist_from_split</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span><span class="p">))</span>
                    
                <span class="n">sk_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sk_names</span><span class="p">)</span>
                <span class="n">dist_from_split</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dist_from_split</span><span class="p">)</span>

                <span class="n">min_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dist_from_split</span><span class="p">)</span>
                <span class="n">min_arg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dist_from_split</span> <span class="o">==</span> <span class="n">min_dist</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">min_nodes</span> <span class="o">=</span> <span class="n">sk_names</span><span class="p">[</span><span class="n">min_arg</span><span class="p">]</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">min_nodes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">error_if_no_one_match</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Split </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s2">) had min_dist (</span><span class="si">{</span><span class="n">min_dist</span><span class="si">}</span><span class="s2">) had more than one match (</span><span class="si">{</span><span class="n">min_nodes</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">error_if_no_one_match</span><span class="p">:</span>
                    <span class="n">min_nodes</span> <span class="o">=</span> <span class="n">min_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">min_dist</span> <span class="o">&gt;</span> <span class="n">distance_max</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Split </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s2">) had min_dist (</span><span class="si">{</span><span class="n">min_dist</span><span class="si">}</span><span class="s2">) that was greater than distance_max (</span><span class="si">{</span><span class="n">distance_max</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

                <span class="n">local_split</span><span class="p">[</span><span class="s2">&quot;node&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_nodes</span>
                <span class="n">local_split</span><span class="p">[</span><span class="s2">&quot;min_distance&quot;</span><span class="p">]</span> <span class="o">=</span>  <span class="n">min_dist</span>

                <span class="n">split_info</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">local_split</span><span class="p">)</span>
                <span class="n">split_counter</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">verbose_loop</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;local_split = </span><span class="si">{</span><span class="n">local_split</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">split_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_records</span><span class="p">(</span><span class="n">split_info</span><span class="p">)</span>
    
    
    <span class="k">if</span> <span class="n">error_on_non_unique_node_names</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">split_df</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">split_df</span><span class="p">[</span><span class="s2">&quot;node&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">split_df</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Not unique nodes&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total split mappings: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">split_df</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">split_df</span></div>

<div class="viewcode-block" id="nodes_with_auto_proof_filter"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.nodes_with_auto_proof_filter">[docs]</a><span class="k">def</span> <span class="nf">nodes_with_auto_proof_filter</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">return_filter_names</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
    <span class="k">return</span> <span class="n">xu</span><span class="o">.</span><span class="n">nodes_with_non_none_attributes</span><span class="p">(</span>
        <span class="n">G</span><span class="p">,</span>
        <span class="n">attribute_name</span><span class="o">=</span><span class="n">nxu</span><span class="o">.</span><span class="n">auto_proof_filter_name_default</span><span class="p">,</span>
        <span class="n">return_attribute_value</span><span class="o">=</span><span class="n">return_filter_names</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span></div>

<div class="viewcode-block" id="set_auto_proof_filter_attribute"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.set_auto_proof_filter_attribute">[docs]</a><span class="k">def</span> <span class="nf">set_auto_proof_filter_attribute</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">split_df</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">split_locations</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">inplace</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">filter_attribute_name</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">default_value</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">error_on_non_unique_node_names</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">filter_axon_on_dendrite_splits</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To take the split locations df and</span>
<span class="sd">    to label the nodes with the right error</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">split_df</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">split_df</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">split_location_node_map_df</span><span class="p">(</span>
            <span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="p">,</span>
            <span class="n">split_locations</span><span class="o">=</span><span class="n">split_locations</span><span class="p">,</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
            <span class="n">error_on_non_unique_node_names</span><span class="o">=</span><span class="n">error_on_non_unique_node_names</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>

    <span class="k">if</span> <span class="n">filter_attribute_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">filter_attribute_name</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">auto_proof_filter_name_default</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

    <span class="n">xu</span><span class="o">.</span><span class="n">set_node_attribute</span><span class="p">(</span>
        <span class="n">G</span><span class="p">,</span>
        <span class="n">attribute_name</span> <span class="o">=</span> <span class="n">filter_attribute_name</span><span class="p">,</span>
        <span class="n">attribute_value</span> <span class="o">=</span> <span class="n">default_value</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">split_df</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">filter_names</span> <span class="o">=</span> <span class="n">split_df</span><span class="p">[</span><span class="s2">&quot;filter_name&quot;</span><span class="p">]</span>
        <span class="n">nodes_to_label</span> <span class="o">=</span> <span class="n">split_df</span><span class="p">[</span><span class="s2">&quot;node&quot;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">n</span><span class="p">,</span><span class="n">f</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">nodes_to_label</span><span class="p">,</span><span class="n">filter_names</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">error_on_non_unique_node_names</span><span class="p">:</span>
                <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">filter_attribute_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">filter_attribute_name</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">filter_attribute_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">filter_attribute_name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nodes with filter attributes&quot;</span><span class="p">)</span>
        <span class="n">nxu</span><span class="o">.</span><span class="n">nodes_with_auto_proof_filter</span><span class="p">(</span>
            <span class="n">G</span><span class="p">,</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">filter_axon_on_dendrite_splits</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;filtering the axon on dendrite splits&quot;</span><span class="p">)</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">filter_axon_on_dendrite_splits_to_most_upstream</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">G</span></div>

<span class="k">def</span> <span class="nf">filter_axon_on_dendrite_splits_to_most_upstream</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">G</span>

<div class="viewcode-block" id="segment_id_from_G"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.segment_id_from_G">[docs]</a><span class="k">def</span> <span class="nf">segment_id_from_G</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">return_split_index</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="n">seg_id</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s2">&quot;segment_id&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">return_split_index</span><span class="p">:</span>
         <span class="k">return</span> <span class="n">seg_id</span><span class="p">,</span><span class="n">G</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s2">&quot;split_index&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">seg_id</span></div>


<span class="c1"># ---------- For filtering parts of the graph ---------</span>
<div class="viewcode-block" id="soma_connected_nodes"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.soma_connected_nodes">[docs]</a><span class="k">def</span> <span class="nf">soma_connected_nodes</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">curr_node</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">soma_node_name_global</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">curr_node</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">curr_node</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">most_upstream_node</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">curr_node</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>


<div class="viewcode-block" id="most_upstream_nodes"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.most_upstream_nodes">[docs]</a><span class="k">def</span> <span class="nf">most_upstream_nodes</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_downstream_count</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get a count of the number of</span>
<span class="sd">    downstream nodes</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    nxu.most_upstream_nodes(</span>
<span class="sd">        G,</span>
<span class="sd">        nodes = [&quot;L1_10&quot;,&quot;L1_2&quot;,&quot;L1_8&quot;,&quot;L0_20&quot;],</span>
<span class="sd">        verbose = True</span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
        
    <span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>

    <span class="n">down_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xu</span><span class="o">.</span><span class="n">n_all_downstream_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">])</span>
    <span class="n">down_count_idx_sorted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">down_count</span><span class="p">))</span>
    <span class="n">nodes_sorted</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">down_count_idx_sorted</span><span class="p">]</span>
    <span class="n">down_count_sorted</span> <span class="o">=</span> <span class="n">down_count</span><span class="p">[</span><span class="n">down_count_idx_sorted</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nodes_sorted = </span><span class="si">{</span><span class="n">nodes_sorted</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;down_count_sorted = </span><span class="si">{</span><span class="n">down_count_sorted</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_downstream_count</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">nodes_sorted</span><span class="p">,</span><span class="n">down_count_sorted</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">nodes_sorted</span></div>

<div class="viewcode-block" id="most_upstream_node"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.most_upstream_node">[docs]</a><span class="k">def</span> <span class="nf">most_upstream_node</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">nxu</span><span class="o">.</span><span class="n">most_upstream_nodes</span><span class="p">(</span>
        <span class="n">G</span><span class="p">,</span>
        <span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
        <span class="n">return_downstream_count</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="most_upstream_coordinate"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.most_upstream_coordinate">[docs]</a><span class="k">def</span> <span class="nf">most_upstream_coordinate</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Get upstream skeleton point of the </span>
<span class="sd">    most upstream node</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">most_upstream_node</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;endpoint_upstream&quot;</span><span class="p">]</span></div>
    
<div class="viewcode-block" id="limb_graphs_from_soma_connected_nodes"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.limb_graphs_from_soma_connected_nodes">[docs]</a><span class="k">def</span> <span class="nf">limb_graphs_from_soma_connected_nodes</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get all of the limb graphs</span>
<span class="sd">    defined by those boardering the soma</span>

<span class="sd">    Pseucode: </span>
<span class="sd">    1) Get all of the soma connected nodes</span>
<span class="sd">    2) For each soma connected node: get the connected subgraph</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    limb_graphs = nxu.limb_graphs_from_soma_connected_nodes(</span>
<span class="sd">    G,</span>
<span class="sd">    verbose = True,</span>
<span class="sd">    plot = False,</span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">soma_conn_nodes</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">soma_connected_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;soma_conn_nodes = </span><span class="si">{</span><span class="n">soma_conn_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">total_limb_graphs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">soma_conn_nodes</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;-- Working on soma node </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">limb_graph</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">limb_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">most_upstream_node</span><span class="o">=</span><span class="n">node</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">most_up_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">most_upstream_node</span><span class="p">(</span><span class="n">limb_graph</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plotting limb with most upstream node </span><span class="si">{</span><span class="n">most_up_node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">nxu</span><span class="o">.</span><span class="n">draw_tree</span><span class="p">(</span><span class="n">limb_graph</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">total_limb_graphs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">limb_graph</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">total_limb_graphs</span></div>


<div class="viewcode-block" id="distance_from_node_to_soma"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.distance_from_node_to_soma">[docs]</a><span class="k">def</span> <span class="nf">distance_from_node_to_soma</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">node</span><span class="p">,</span>
    <span class="n">include_self_distance</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">distance_attribute</span> <span class="o">=</span> <span class="s2">&quot;skeletal_length&quot;</span><span class="p">,</span>
    <span class="n">destination_node</span> <span class="o">=</span> <span class="s2">&quot;S0&quot;</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_path</span><span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find the distance of a node from soma</span>
<span class="sd">    (both with inclusion and without of its own skeletal length)</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) </span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">total_lengths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">node_path</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Finding distance from </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">destination_node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">include_self_distance</span><span class="p">:</span>
        <span class="n">total_lengths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">distance_attribute</span><span class="p">])</span>
        <span class="n">node_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        
    <span class="c1"># here is where can check if the attribute already exists</span>

    <span class="n">upstream_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">upstream_node</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">)</span>

    <span class="k">while</span> <span class="n">upstream_node</span> <span class="o">!=</span> <span class="n">destination_node</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Working on upstream node </span><span class="si">{</span><span class="n">upstream_node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">node_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">upstream_node</span><span class="p">)</span>
        <span class="n">total_lengths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">upstream_node</span><span class="p">][</span><span class="n">distance_attribute</span><span class="p">])</span>
        <span class="n">upstream_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">upstream_node</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">upstream_node</span><span class="p">)</span>

    <span class="n">path_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">total_lengths</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;path_length = </span><span class="si">{</span><span class="n">path_length</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Path to soma: </span><span class="si">{</span><span class="n">node_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Path </span><span class="si">{</span><span class="n">distance_attribute</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">total_lengths</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_path</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">path_length</span><span class="p">,</span><span class="n">node_path</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">path_length</span></div>
    
<div class="viewcode-block" id="distance_upstream_from_soma"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.distance_upstream_from_soma">[docs]</a><span class="k">def</span> <span class="nf">distance_upstream_from_soma</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">node</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">from_attributes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    nxu.distance_upstream_from_soma(</span>
<span class="sd">    G,</span>
<span class="sd">    &quot;L0_19&quot;,</span>
<span class="sd">    verbose = True,   </span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">from_attributes</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;soma_distance_skeletal&quot;</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">distance_from_node_to_soma</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">node</span><span class="p">,</span>
    <span class="n">include_self_distance</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
    <span class="n">return_path</span><span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="distance_downstream_from_soma"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.distance_downstream_from_soma">[docs]</a><span class="k">def</span> <span class="nf">distance_downstream_from_soma</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">node</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">from_attributes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ex: </span>
<span class="sd">    nxu.distance_downstream_from_soma(</span>
<span class="sd">        G,</span>
<span class="sd">        &quot;L0_19&quot;,</span>
<span class="sd">        verbose = True,   </span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">from_attributes</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;soma_distance_skeletal&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;skeletal_length&quot;</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">distance_from_node_to_soma</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">node</span><span class="p">,</span>
    <span class="n">include_self_distance</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
    <span class="n">return_path</span><span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span></div>
    
<div class="viewcode-block" id="distance_from_soma_df"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.distance_from_soma_df">[docs]</a><span class="k">def</span> <span class="nf">distance_from_soma_df</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">distance_type</span> <span class="o">=</span> <span class="s2">&quot;upstream&quot;</span><span class="p">,</span>
    <span class="n">from_attributes</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Find all the soma distances of </span>
<span class="sd">    all the nodes</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">limb_branch_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

    <span class="n">dist_dict</span> <span class="o">=</span> <span class="p">[{</span><span class="s2">&quot;node&quot;</span><span class="p">:</span><span class="n">n</span><span class="p">,</span><span class="s2">&quot;soma_distance&quot;</span><span class="p">:</span><span class="nb">getattr</span><span class="p">(</span><span class="n">nxu</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;distance_</span><span class="si">{</span><span class="n">distance_type</span><span class="si">}</span><span class="s2">_from_soma&quot;</span><span class="p">)(</span><span class="n">G</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">from_attributes</span><span class="o">=</span><span class="n">from_attributes</span><span class="p">)}</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">]</span>

    <span class="n">dist_dict</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_records</span><span class="p">(</span><span class="n">dist_dict</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dist_dict</span></div>

<div class="viewcode-block" id="distance_upstream_from_soma_df"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.distance_upstream_from_soma_df">[docs]</a><span class="k">def</span> <span class="nf">distance_upstream_from_soma_df</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">from_attributes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
    
    <span class="k">return</span> <span class="n">nxu</span><span class="o">.</span><span class="n">distance_from_soma_df</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">,</span>
    <span class="n">distance_type</span> <span class="o">=</span> <span class="s2">&quot;upstream&quot;</span><span class="p">,</span>
    <span class="n">from_attributes</span><span class="o">=</span><span class="n">from_attributes</span><span class="p">,)</span></div>

<div class="viewcode-block" id="distance_downstream_from_soma_df"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.distance_downstream_from_soma_df">[docs]</a><span class="k">def</span> <span class="nf">distance_downstream_from_soma_df</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">from_attributes</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="n">nxu</span><span class="o">.</span><span class="n">distance_from_soma_df</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">,</span>
    <span class="n">distance_type</span> <span class="o">=</span> <span class="s2">&quot;downstream&quot;</span><span class="p">,</span>
    <span class="n">from_attributes</span><span class="o">=</span><span class="n">from_attributes</span><span class="p">,)</span></div>

<div class="viewcode-block" id="nodes_distance_query_from_soma"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.nodes_distance_query_from_soma">[docs]</a><span class="k">def</span> <span class="nf">nodes_distance_query_from_soma</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">distance_threshold</span><span class="p">,</span>
    <span class="n">within_distance</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">distance_type</span> <span class="o">=</span> <span class="s2">&quot;upstream&quot;</span><span class="p">,</span>
    <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">return_subgraph</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">return_soma_with_sugraph</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">maintain_skeleton_connectivity</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">from_attributes</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Find all the nodes within</span>
<span class="sd">    a certain distance or farther away than</span>
<span class="sd">    a certain distance from soma</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># calculates the distance if not already available</span>
    <span class="k">if</span> <span class="n">from_attributes</span><span class="p">:</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">nxf</span><span class="o">.</span><span class="n">add_any_missing_node_features</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="n">dist_df</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">nxu</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;distance_</span><span class="si">{</span><span class="n">distance_type</span><span class="si">}</span><span class="s2">_from_soma_df&quot;</span><span class="p">)(</span><span class="n">G</span><span class="p">,</span><span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">,</span>
                                                                        <span class="n">from_attributes</span><span class="o">=</span><span class="n">from_attributes</span><span class="p">)</span>
    
    
    
    
    <span class="k">if</span> <span class="n">within_distance</span><span class="p">:</span>
        <span class="n">query</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;soma_distance &lt;= </span><span class="si">{</span><span class="n">distance_threshold</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">query_descriptor</span> <span class="o">=</span> <span class="s2">&quot;closer&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">query</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;soma_distance &gt; </span><span class="si">{</span><span class="n">distance_threshold</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">query_descriptor</span> <span class="o">=</span> <span class="s2">&quot;farther&quot;</span>

    <span class="n">filt_df</span> <span class="o">=</span> <span class="n">dist_df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
    
    <span class="n">filt_nodes</span> <span class="o">=</span> <span class="n">filt_df</span><span class="p">[</span><span class="s2">&quot;node&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Nodes </span><span class="si">{</span><span class="n">distance_type</span><span class="si">}</span><span class="s2"> dist </span><span class="si">{</span><span class="n">query_descriptor</span><span class="si">}</span><span class="s2"> than </span><span class="si">{</span><span class="n">distance_threshold</span><span class="si">}</span><span class="s2"> from soma (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">filt_nodes</span><span class="p">)</span><span class="si">}</span><span class="s2">):</span><span class="se">\n</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">filt_nodes</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>
        
        
    <span class="k">if</span> <span class="n">return_subgraph</span><span class="p">:</span>
        
        <span class="k">if</span> <span class="n">return_soma_with_sugraph</span><span class="p">:</span>
            <span class="n">filt_nodes</span> <span class="o">+=</span> <span class="p">[</span><span class="n">nxu</span><span class="o">.</span><span class="n">soma_node_name_global</span><span class="p">]</span>
            
        <span class="c1"># Old way:</span>
        <span class="c1">#G_sub = G.subgraph(filt_nodes).copy()</span>
        
        <span class="n">node_to_delete</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()),</span><span class="n">filt_nodes</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_to_delete</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">G_sub</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span>
            <span class="n">G</span><span class="p">,</span>
            <span class="n">node_to_delete</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">inplace</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">maintain_skeleton_connectivity</span><span class="o">=</span><span class="n">maintain_skeleton_connectivity</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">G_sub</span> <span class="o">=</span> <span class="n">G</span>
       
        
        <span class="k">return</span> <span class="n">G_sub</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">filt_nodes</span></div>

<div class="viewcode-block" id="nodes_within_distance_from_soma"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.nodes_within_distance_from_soma">[docs]</a><span class="k">def</span> <span class="nf">nodes_within_distance_from_soma</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">distance_threshold</span><span class="p">,</span>
    <span class="n">distance_type</span> <span class="o">=</span> <span class="s2">&quot;upstream&quot;</span><span class="p">,</span>
    <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">return_subgraph</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">from_attributes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ex: </span>
<span class="sd">    distance_threshold = 1000</span>
<span class="sd">    curr_nodes = nxu.nodes_within_distance_from_soma(G,distance_threshold = distance_threshold,verbose = True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">return_G</span> <span class="o">=</span>  <span class="n">nxu</span><span class="o">.</span><span class="n">nodes_distance_query_from_soma</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">distance_threshold</span><span class="p">,</span>
    <span class="n">within_distance</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">distance_type</span> <span class="o">=</span> <span class="n">distance_type</span><span class="p">,</span>
    <span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">,</span>
    <span class="n">return_subgraph</span><span class="o">=</span><span class="n">return_subgraph</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
    <span class="n">from_attributes</span><span class="o">=</span><span class="n">from_attributes</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span>
    
    
    <span class="k">return</span> <span class="n">return_G</span></div>
    
<div class="viewcode-block" id="nodes_farther_than_distance_from_soma"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.nodes_farther_than_distance_from_soma">[docs]</a><span class="k">def</span> <span class="nf">nodes_farther_than_distance_from_soma</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">distance_threshold</span><span class="p">,</span>
    <span class="n">distance_type</span> <span class="o">=</span> <span class="s2">&quot;upstream&quot;</span><span class="p">,</span>
    <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">return_subgraph</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">from_attributes</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
    
    <span class="k">return</span> <span class="n">nxu</span><span class="o">.</span><span class="n">nodes_distance_query_from_soma</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">distance_threshold</span><span class="p">,</span>
    <span class="n">within_distance</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">distance_type</span> <span class="o">=</span> <span class="n">distance_type</span><span class="p">,</span>
    <span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">,</span>
    <span class="n">return_subgraph</span><span class="o">=</span><span class="n">return_subgraph</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
    <span class="n">from_attributes</span><span class="o">=</span><span class="n">from_attributes</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="nodes_within_distance_upstream_from_soma"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.nodes_within_distance_upstream_from_soma">[docs]</a><span class="k">def</span> <span class="nf">nodes_within_distance_upstream_from_soma</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">distance_threshold</span><span class="p">,</span>
    <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">return_subgraph</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
    
    <span class="k">return</span> <span class="n">nxu</span><span class="o">.</span><span class="n">nodes_within_distance_from_soma</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">distance_threshold</span><span class="p">,</span>
    <span class="n">distance_type</span> <span class="o">=</span> <span class="s2">&quot;upstream&quot;</span><span class="p">,</span>
    <span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">,</span>
    <span class="n">return_subgraph</span><span class="o">=</span><span class="n">return_subgraph</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="soma_filter_by_complete_graph"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.soma_filter_by_complete_graph">[docs]</a><span class="k">def</span> <span class="nf">soma_filter_by_complete_graph</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">inplace</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">connect_previous_touching_soma_nodes</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Problem: Want to resolve the soma so it does</span>
<span class="sd">    not affect...</span>

<span class="sd">    Solution 1: Delete the soma network and then </span>
<span class="sd">    connect all the </span>

<span class="sd">    Pseudocode:</span>
<span class="sd">    1) Connect all the soma connecting nodes</span>
<span class="sd">    2) Get the subgraph of only the limb branches</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    G_no_soma = nxu.soma_filter_by_complete_graph(G_filt,plot=True)</span>
<span class="sd">    nxu.draw_tree(G_no_soma)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">connect_previous_touching_soma_nodes</span><span class="p">:</span>
        <span class="n">soma_conn_nodes</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">soma_connected_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;soma_conn_nodes (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">soma_conn_nodes</span><span class="p">)</span><span class="si">}</span><span class="s2">)= </span><span class="si">{</span><span class="n">soma_conn_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">all_conn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([[(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">soma_conn_nodes</span> <span class="k">if</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">soma_conn_nodes</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;New connections (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">all_conn</span><span class="p">)</span><span class="si">}</span><span class="s2">) = </span><span class="si">{</span><span class="n">all_conn</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">all_conn</span><span class="p">)</span>
        
    <span class="n">return_G</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">limb_branch_subgraph</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">return_G</span><span class="p">),</span><span class="n">with_labels</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">return_G</span></div>


<div class="viewcode-block" id="nodes_with_auto_proof_filter_type"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.nodes_with_auto_proof_filter_type">[docs]</a><span class="k">def</span> <span class="nf">nodes_with_auto_proof_filter_type</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">filter_type</span><span class="p">,</span>
    <span class="n">filter_feature</span> <span class="o">=</span> <span class="s2">&quot;auto_proof_filter&quot;</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get all nodes with a certain filter marking </span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    nxu.nodes_with_auto_proof_filter_type(G,filter_type=&quot;axon_on_dendrite&quot;,verbose = True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">filter_df</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">node_df</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">filter_feature</span><span class="si">}</span><span class="s2"> == </span><span class="si">{</span><span class="n">filter_feature</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">nodes_with_filter_type</span> <span class="o">=</span> <span class="n">filter_df</span><span class="p">[</span><span class="n">filter_df</span><span class="p">[</span><span class="n">filter_feature</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">filter_type</span><span class="p">)][</span><span class="n">xu</span><span class="o">.</span><span class="n">upstream_name</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nodes with </span><span class="si">{</span><span class="n">filter_type</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">nodes_with_filter_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">nodes_with_filter_type</span></div>

<div class="viewcode-block" id="clear_nodes_auto_proof_filter_feature"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.clear_nodes_auto_proof_filter_feature">[docs]</a><span class="k">def</span> <span class="nf">clear_nodes_auto_proof_filter_feature</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">nodes</span><span class="p">,</span>
    <span class="n">filter_feature</span> <span class="o">=</span> <span class="s2">&quot;auto_proof_filter&quot;</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
        <span class="n">curr_filter_name</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">filter_feature</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Clearning </span><span class="si">{</span><span class="n">curr_filter_name</span><span class="si">}</span><span class="s2"> for node </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>
        <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">filter_feature</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">G</span></div>

<div class="viewcode-block" id="filter_axon_on_dendrite_splits_to_most_upstream"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.filter_axon_on_dendrite_splits_to_most_upstream">[docs]</a><span class="k">def</span> <span class="nf">filter_axon_on_dendrite_splits_to_most_upstream</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">inplace</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">filter_out_only_if_parent_in_split</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To reduce the axon on dendrite merges to only those</span>
<span class="sd">    that are the most upstream of the group</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode:</span>
<span class="sd">    1) Get all of the nodes that are in axon on dendrite mergers</span>
<span class="sd">    2) For each node:</span>
<span class="sd">    a. Get either just the parent or all of the upstream node</span>
<span class="sd">    b. add node to list ot be cleared if has upstream axon on dendrite</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    G_filt = filter_axon_on_dendrite_splits_to_most_upstream(G,verbose = True)</span>
<span class="sd">    nxu.nodes_with_auto_proof_filter(G_filt,&quot;axon_on_dendrite&quot;)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">axon_on_dendrite_nodes</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">nodes_with_auto_proof_filter_type</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="s2">&quot;axon_on_dendrite&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;axon_on_dendrite_nodes (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">axon_on_dendrite_nodes</span><span class="p">)</span><span class="si">}</span><span class="s2">) = </span><span class="si">{</span><span class="n">axon_on_dendrite_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="n">nodes_to_clear</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">axon_on_dendrite_nodes</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">filter_out_only_if_parent_in_split</span><span class="p">:</span>
            <span class="n">up_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">xu</span><span class="o">.</span><span class="n">upstream_node</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">n</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">up_nodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">all_upstream_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
            
        <span class="n">ax_on_dendr_upstream</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">axon_on_dendrite_nodes</span><span class="p">,</span><span class="n">up_nodes</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ax_on_dendr_upstream</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Removing node </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> because had upstream axon on dendrite: </span><span class="si">{</span><span class="n">ax_on_dendr_upstream</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">nodes_to_clear</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            
    <span class="n">G</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">clear_nodes_auto_proof_filter_feature</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">nodes_to_clear</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span>
        
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">axon_on_dendrite_nodes</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">nodes_with_auto_proof_filter_type</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="s2">&quot;axon_on_dendrite&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;axon_on_dendrite_nodes AFTER FILTERING (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">axon_on_dendrite_nodes</span><span class="p">)</span><span class="si">}</span><span class="s2">) = </span><span class="si">{</span><span class="n">axon_on_dendrite_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">G</span></div>
    
    
<div class="viewcode-block" id="fix_flipped_skeletons"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.fix_flipped_skeletons">[docs]</a><span class="k">def</span> <span class="nf">fix_flipped_skeletons</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To fix the skeleton data</span>
<span class="sd">    in Graph objects if they are</span>
<span class="sd">    not aligned correctly</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    segment_id,split_index = 864691135162621741,0</span>

<span class="sd">    G_obj = hdju.graph_obj_from_auto_proof_stage(</span>
<span class="sd">        segment_id=segment_id,</span>
<span class="sd">        split_index=split_index,</span>
<span class="sd">    )</span>
<span class="sd">    </span>
<span class="sd">    G_obj = fix_flipped_skeletons(G_obj,verbose = True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">node_flipped</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
        <span class="k">if</span> <span class="s2">&quot;s&quot;</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
            <span class="k">continue</span>
        <span class="n">curr_dict</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="n">endpt_up</span> <span class="o">=</span> <span class="n">curr_dict</span><span class="p">[</span><span class="s2">&quot;endpoint_upstream&quot;</span><span class="p">]</span>
        <span class="n">sk_up</span> <span class="o">=</span> <span class="n">curr_dict</span><span class="p">[</span><span class="s2">&quot;skeleton_data&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">endpt_up</span><span class="p">,</span><span class="n">sk_up</span><span class="p">):</span>
            <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;skeleton_data&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">curr_dict</span><span class="p">[</span><span class="s2">&quot;skeleton_data&quot;</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">node_flipped</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Nodes with skeleton flipped: </span><span class="si">{</span><span class="n">node_flipped</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">G</span></div>

<div class="viewcode-block" id="soma_only_graph"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.soma_only_graph">[docs]</a><span class="k">def</span> <span class="nf">soma_only_graph</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">soma_node_name</span><span class="o">=</span><span class="n">soma_node_name_global</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To check if only a soma node is in the nodes</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">node_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()]</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">node_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">soma_node_name</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span></div>
    
<span class="c1"># --------- For outputing graph attributes --------</span>
<div class="viewcode-block" id="compartment_from_node"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.compartment_from_node">[docs]</a><span class="k">def</span> <span class="nf">compartment_from_node</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">replace_underscore</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get the compartment from</span>
<span class="sd">    a node in a graph</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s2">&quot;graph&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">G</span><span class="p">))</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
     
    <span class="n">comp</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="s2">&quot;compartment&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">replace_underscore</span><span class="p">:</span>
        <span class="n">comp</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">comp</span></div>

<div class="viewcode-block" id="width_from_node"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.width_from_node">[docs]</a><span class="k">def</span> <span class="nf">width_from_node</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">n</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get the width of a certain node</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    from neuron_morphology_tools from neurd import neuron_nx_utils as nxu</span>
<span class="sd">    nxu.width_from_node(</span>
<span class="sd">     G = G_obj,</span>
<span class="sd">     n = &quot;L0_5&quot;,</span>
<span class="sd">        verbose = True</span>

<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">curr_key</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="n">width</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_key</span><span class="p">[</span><span class="s2">&quot;width_new&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">width</span> <span class="o">=</span> <span class="n">curr_key</span><span class="p">[</span><span class="s2">&quot;width_new&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;no_spine_median_mesh_center&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">width</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Getting width from default width (not new width)&quot;</span><span class="p">)</span>
        <span class="n">width</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;width&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">width</span></div>


<div class="viewcode-block" id="attribute_graph_from_graph_obj"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.attribute_graph_from_graph_obj">[docs]</a><span class="k">def</span> <span class="nf">attribute_graph_from_graph_obj</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">attribute</span><span class="p">,</span>
    <span class="n">ids_name</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_attribute_nodes</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_attribute_nodes_to_branch_dict</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">return_upstream_dist</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">exclude_presyn</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To convert a graph object into </span>
<span class="sd">    a graph where an attribute of the graph </span>
<span class="sd">    object are the nodes along with the branch points.</span>
<span class="sd">    The edges between nodes will be the upstream distance.</span>

<span class="sd">    Application: Will help find the distances between the attributes</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">attribute_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">attribute</span><span class="si">}</span><span class="s2">_data&quot;</span>

    <span class="k">if</span> <span class="n">ids_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">attribute</span> <span class="o">==</span> <span class="s2">&quot;synapse&quot;</span><span class="p">:</span>
            <span class="n">ids_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;syn_id&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ids_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">attribute</span><span class="si">}</span><span class="s2">_id&quot;</span>

    <span class="n">graph_edges</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">graph_weights</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ids_counter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">attribute_ids</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">attribute_ids_branch_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">upstream_dist</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span><span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()}</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="n">curr_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="n">upstream_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">upstream_node</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">upstream_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">upstream_node</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;L-1&quot;</span>

        <span class="n">comp</span> <span class="o">=</span> <span class="n">compartment_from_node</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">attribute_data</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="n">attribute_name</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">attribute</span> <span class="o">==</span> <span class="s2">&quot;synapse&quot;</span> <span class="ow">and</span> <span class="n">exclude_presyn</span><span class="p">:</span>
            <span class="c1">#print(f&quot;Excluding presyns&quot;)</span>
            <span class="n">attribute_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">attribute_data</span> <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="s2">&quot;syn_type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;postsyn&quot;</span><span class="p">]</span>

        <span class="c1">#if len(attribute_data) &gt; 0:</span>
        <span class="n">upstream_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;upstream_dist&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">attribute_data</span><span class="p">])</span>

        <span class="c1"># generates the ids for the current branch</span>
        <span class="n">ids_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">k</span><span class="p">[</span><span class="n">ids_name</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">attribute_data</span><span class="p">])</span>
        <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">ids_data</span><span class="p">:</span>
            <span class="n">ids_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ids_counter</span><span class="p">,</span><span class="n">ids_counter</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">attribute_data</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
            <span class="n">ids_counter</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">attribute_data</span><span class="p">)</span>
            
        
        <span class="n">attribute_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ids_data</span><span class="p">)</span>
        <span class="n">attribute_ids_branch_dict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">):</span><span class="n">n</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ids_data</span><span class="p">})</span>
        <span class="n">upstream_dist</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">):</span><span class="n">upstream_data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ids_data</span><span class="p">)})</span>

        <span class="n">order_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">upstream_data</span><span class="p">)</span>
        <span class="n">upstream_data_sort</span> <span class="o">=</span> <span class="n">upstream_data</span><span class="p">[</span><span class="n">order_idx</span><span class="p">]</span>
        <span class="n">ids_data_sort</span> <span class="o">=</span> <span class="n">ids_data</span><span class="p">[</span><span class="n">order_idx</span><span class="p">]</span>

        <span class="n">upstream_data_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span><span class="n">upstream_data_sort</span><span class="p">,[</span><span class="n">key</span><span class="p">[</span><span class="s2">&quot;skeletal_length&quot;</span><span class="p">]]])</span>
        <span class="n">ids_data_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([[</span><span class="n">upstream_node</span><span class="p">],</span><span class="n">ids_data_sort</span><span class="p">,[</span><span class="n">n</span><span class="p">]])</span>

        <span class="n">edge_weights</span> <span class="o">=</span> <span class="n">upstream_data_sort</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">upstream_data_sort</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">edge_weights</span><span class="p">[</span><span class="n">edge_weights</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">ids_data_sort</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">ids_data_sort</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span><span class="o">.</span><span class="n">T</span>
        <span class="c1">#weighted_edges = np.vstack([edges,edge_weights]).T</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; --&gt; node </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">: # of edges = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1">#print(f&quot;weighted_edges = {weighted_edges}&quot;)</span>

        <span class="n">graph_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
        <span class="n">graph_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge_weights</span><span class="p">)</span>


    <span class="n">output_G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph_edges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">graph_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">graph_edges</span><span class="p">)</span>
        <span class="n">graph_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">graph_weights</span><span class="p">)</span>
        <span class="n">output_G</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">edges_and_weights_to_graph</span><span class="p">(</span><span class="n">graph_edges</span><span class="p">,</span>
                              <span class="n">weights_list</span><span class="o">=</span><span class="n">graph_weights</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">attribute_ids</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">attribute_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">attribute_ids</span><span class="p">)</span>
        
    <span class="n">attribute_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">attribute_ids</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;str&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total Graph stats:&quot;</span><span class="p">)</span>
        <span class="n">xu</span><span class="o">.</span><span class="n">print_node_edges_counts</span><span class="p">(</span><span class="n">output_G</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="ow">not</span> <span class="n">return_attribute_nodes</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">return_attribute_nodes_to_branch_dict</span><span class="p">)</span>
        <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">return_upstream_dist</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">output_G</span>
    <span class="n">return_value</span> <span class="o">=</span><span class="p">[</span><span class="n">output_G</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">return_attribute_nodes</span><span class="p">:</span>
        <span class="n">return_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">attribute_ids</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_attribute_nodes_to_branch_dict</span><span class="p">:</span>
        <span class="n">return_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">attribute_ids_branch_dict</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">return_upstream_dist</span><span class="p">:</span>
        <span class="n">return_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">upstream_dist</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">return_value</span></div>
    
    
<div class="viewcode-block" id="plot_inter_attribute_intervals"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.plot_inter_attribute_intervals">[docs]</a><span class="k">def</span> <span class="nf">plot_inter_attribute_intervals</span><span class="p">(</span>
    <span class="n">inter_attribute_info</span><span class="p">,</span>
    <span class="n">title</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
    <span class="n">attribute</span> <span class="o">=</span> <span class="s2">&quot;attribute&quot;</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To plot the histograms of the</span>
<span class="sd">    closest attribute arrays</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">inter_attribute_info</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="n">inter_attribute_info</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="n">inter_attribute_info</span><span class="p">}</span>
        
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">inter_attribute_info</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Combining the branch specific dicts&quot;</span><span class="p">)</span>
        <span class="n">inter_attribute_info</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">inter_attribute_info</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        
    <span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inter_attribute_info</span><span class="p">)):</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">inter_attribute_info</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mi">1000</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2"> Hop&quot;</span><span class="p">,</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="n">bins</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Closest </span><span class="si">{</span><span class="n">attribute</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Distance (um)&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Count&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        
    <span class="k">return</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="inter_attribute_intervals_from_G"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.inter_attribute_intervals_from_G">[docs]</a><span class="k">def</span> <span class="nf">inter_attribute_intervals_from_G</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">attribute</span><span class="p">,</span>
    <span class="n">n_closest_neighbors</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">default_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">debug_time</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">separate_branches</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">return_upstream_dist</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">exclude_presyn</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find the k inter-attribute</span>
<span class="sd">    distances for the attributes on the graph</span>

<span class="sd">    1) Turn the graph into an attribute graph</span>
<span class="sd">    2) For every attribute id:</span>
<span class="sd">        Remove the attribute id from the total list</span>
<span class="sd">        a. For 1 to k (the number of attributes away):</span>
<span class="sd">           if list empty then add distance of -1 and continue</span>
<span class="sd">           Calculate the closest neighbors from remaining nodes and get distance</span>

<span class="sd">           Save the distance</span>
<span class="sd">           Remove that closest neighbor from the list</span>

<span class="sd">    3) Return the lists of closest distances</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="p">(</span><span class="n">G_disc</span><span class="p">,</span>
     <span class="n">att_nodes</span><span class="p">,</span>
     <span class="n">att_to_branch_dict</span><span class="p">,</span>
     <span class="n">att_to_upstream_dist</span><span class="p">)</span><span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">attribute_graph_from_graph_obj</span><span class="p">(</span>
        <span class="n">G</span><span class="p">,</span>
        <span class="n">attribute</span> <span class="o">=</span> <span class="n">attribute</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
        <span class="n">return_attribute_nodes</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">return_attribute_nodes_to_branch_dict</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">return_upstream_dist</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">exclude_presyn</span> <span class="o">=</span> <span class="n">exclude_presyn</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">upstream_dists</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:[]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()}</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">separate_branches</span><span class="p">:</span>
        <span class="n">closest_neighbors</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:[]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n_closest_neighbors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)}</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="n">closest_neighbors</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:{</span><span class="n">v</span><span class="p">:[]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()}</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n_closest_neighbors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)}</span>
        

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">att_nodes</span><span class="p">):</span>
        <span class="n">local_nodes</span> <span class="o">=</span> <span class="n">att_nodes</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">local_nodes</span> <span class="o">=</span> <span class="n">local_nodes</span><span class="p">[</span><span class="n">local_nodes</span> <span class="o">!=</span> <span class="n">n</span><span class="p">]</span>
        <span class="n">previous_closest</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="n">upstream_dists</span><span class="p">[</span><span class="n">att_to_branch_dict</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">att_to_upstream_dist</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">closest_neighbors</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">previous_closest</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">local_nodes</span> <span class="o">=</span> <span class="n">local_nodes</span><span class="p">[</span><span class="n">local_nodes</span> <span class="o">!=</span> <span class="n">previous_closest</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">local_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">default_value</span>
                <span class="n">short_path_dist</span> <span class="o">=</span> <span class="n">default_value</span>
                <span class="n">n2</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
                    <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                <span class="n">short_path_dist</span><span class="p">,</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">shortest_path_between_two_sets_of_nodes</span><span class="p">(</span>
                    <span class="n">G_disc</span><span class="p">,</span>
                    <span class="n">node_list_1</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="p">],</span>
                    <span class="n">node_list_2</span> <span class="o">=</span> <span class="n">local_nodes</span><span class="p">,</span>
                    <span class="n">return_node_pairs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">return_path_distance</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time for calculating shortest path = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>


            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">th Closest neighbor of </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> was </span><span class="si">{</span><span class="n">n2</span><span class="si">}</span><span class="s2"> with path distance </span><span class="si">{</span><span class="n">short_path_dist</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">previous_closest</span> <span class="o">=</span> <span class="n">n2</span>
            
            <span class="k">if</span> <span class="ow">not</span> <span class="n">separate_branches</span><span class="p">:</span>
                <span class="n">closest_neighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">short_path_dist</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">closest_neighbors</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">att_to_branch_dict</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">short_path_dist</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">separate_branches</span><span class="p">:</span>
        <span class="n">closest_neighbors</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">closest_neighbors</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">closest_neighbors</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">closest_neighbors</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                <span class="n">closest_neighbors</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">closest_neighbors</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">v</span><span class="p">])</span>
        

    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span> 
        <span class="n">nxu</span><span class="o">.</span><span class="n">plot_inter_attribute_intervals</span><span class="p">(</span>
            <span class="n">closest_neighbors</span><span class="p">,</span>
            <span class="n">attribute</span><span class="o">=</span><span class="n">attribute</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        
    <span class="k">if</span> <span class="n">return_upstream_dist</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">closest_neighbors</span><span class="p">,</span><span class="n">upstream_dists</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">closest_neighbors</span></div>


<div class="viewcode-block" id="n_data_attribues"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.n_data_attribues">[docs]</a><span class="k">def</span> <span class="nf">n_data_attribues</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">attribute</span><span class="p">,</span><span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">exclude_presyn</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get the number of data attributes</span>
<span class="sd">    belonging to a branch</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span> <span class="k">if</span> <span class="s2">&quot;S&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">k</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="p">]</span>
        
    <span class="n">curr_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n1</span><span class="p">][</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">attribute</span><span class="si">}</span><span class="s2">_data&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">n1</span> <span class="ow">in</span> <span class="n">n</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">exclude_presyn</span> <span class="ow">and</span> <span class="n">attribute</span> <span class="o">==</span> <span class="s2">&quot;synapse&quot;</span><span class="p">:</span>
        <span class="n">curr_data</span> <span class="o">=</span> <span class="p">[[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">v</span>
                     <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="s2">&quot;syn_type&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;presyn&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">curr_data</span><span class="p">]</span>
        
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_data</span><span class="p">])</span></div>




<div class="viewcode-block" id="inter_attribute_G_preprocessing"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.inter_attribute_G_preprocessing">[docs]</a><span class="k">def</span> <span class="nf">inter_attribute_G_preprocessing</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">dendrite_only</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">remove_starter_branches</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
    
    <span class="k">if</span> <span class="n">dendrite_only</span><span class="p">:</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">dendrite_subgraph</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">remove_starter_branches</span><span class="p">:</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">remove_small_starter_branches</span><span class="p">(</span>
                <span class="n">G</span><span class="p">,</span>
                <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                <span class="n">maintain_skeleton_connectivity</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">G</span></div>
    
    

<div class="viewcode-block" id="inter_attribute_intervals_dict_from_neuron_G"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.inter_attribute_intervals_dict_from_neuron_G">[docs]</a><span class="k">def</span> <span class="nf">inter_attribute_intervals_dict_from_neuron_G</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">attribute</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">dendrite_only</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">remove_starter_branches</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="c1">#return_attribute_density = True,</span>
    <span class="c1">#return_compartment = True</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">n_closest_neighbors</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">branch_features_to_add</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;mesh_volume&quot;</span><span class="p">,</span>
        <span class="s1">&#39;n_synapses_head&#39;</span><span class="p">,</span>
        <span class="s1">&#39;n_synapses_neck&#39;</span><span class="p">,</span>
        <span class="s1">&#39;n_synapses_no_head&#39;</span><span class="p">,</span>
        <span class="s1">&#39;n_synapses_post&#39;</span><span class="p">,</span>
        <span class="s1">&#39;n_synapses_pre&#39;</span><span class="p">,</span>
        <span class="s1">&#39;n_synapses_shaft&#39;</span><span class="p">,</span>
        <span class="s1">&#39;n_synapses_spine&#39;</span><span class="p">,</span>
        <span class="s2">&quot;total_spine_volume&quot;</span><span class="p">,</span>
        <span class="s2">&quot;soma_distance_euclidean&quot;</span><span class="p">,</span>
        <span class="s1">&#39;parent_skeletal_angle&#39;</span><span class="p">,</span>
        <span class="s1">&#39;siblings_skeletal_angle_max&#39;</span><span class="p">,</span>
        <span class="s1">&#39;width_upstream&#39;</span><span class="p">,</span>
         <span class="s1">&#39;width_downstream&#39;</span><span class="p">,</span>
        <span class="p">),</span>
    
    
    <span class="c1"># -------- arguments for random shuffling -------</span>
    <span class="n">shuffle_upstream_dist</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">attribute_sk_nullification</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">exclude_presyn</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">discretization_length</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
    <span class="n">seed</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Want to build an inter attribute </span>
<span class="sd">    distance for all branches in a neuron</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">attribute</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">attribute</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;spine&quot;</span><span class="p">,</span><span class="s2">&quot;synapse&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">attribute</span><span class="p">)</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="n">attribute</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">attribute</span><span class="p">)</span>
    <span class="n">attribute</span><span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">convert_to_array_like</span><span class="p">(</span><span class="n">attribute</span><span class="p">)</span>
    <span class="n">data_dicts</span> <span class="o">=</span> <span class="p">[]</span>


    <span class="k">if</span> <span class="ow">not</span> <span class="n">nxu</span><span class="o">.</span><span class="n">soma_only_graph</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
        
        <span class="n">G</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">inter_attribute_G_preprocessing</span><span class="p">(</span>
            <span class="n">G</span><span class="p">,</span>
            <span class="n">dendrite_only</span> <span class="o">=</span> <span class="n">dendrite_only</span><span class="p">,</span>
            <span class="n">remove_starter_branches</span> <span class="o">=</span> <span class="n">remove_starter_branches</span><span class="p">,</span>
        <span class="p">)</span>
        
        <span class="n">limb_graphs</span><span class="p">,</span><span class="n">limb_idxs</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">all_limb_graphs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">return_idxs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of limb graphs: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">limb_graphs</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span><span class="n">G_limb</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">limb_idxs</span><span class="p">,</span><span class="n">limb_graphs</span><span class="p">):</span>
            
            <span class="k">if</span> <span class="n">shuffle_upstream_dist</span><span class="p">:</span> 
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Applying shuffle_upstream_dist&quot;</span><span class="p">)</span>
                <span class="n">G_limb</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">shuffle_upstream_dist_on_data_attribute</span><span class="p">(</span>
                    <span class="n">G_limb</span><span class="p">,</span>
                    <span class="n">attribute</span> <span class="o">=</span> <span class="n">attribute</span><span class="p">,</span>
                    <span class="n">attribute_sk_nullification</span> <span class="o">=</span> <span class="n">attribute_sk_nullification</span><span class="p">,</span>
                    <span class="n">exclude_presyn</span> <span class="o">=</span> <span class="n">exclude_presyn</span><span class="p">,</span>
                    <span class="n">discretization_length</span> <span class="o">=</span> <span class="n">discretization_length</span><span class="p">,</span>
                    <span class="n">seed</span> <span class="o">=</span> <span class="n">seed</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--------Working on Limb </span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">---------&quot;</span><span class="p">)</span>

            <span class="n">limb_dicts</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G_limb</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
                <span class="n">curr_dt</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">branch</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
                                   <span class="n">compartment</span><span class="o">=</span><span class="n">nxu</span><span class="o">.</span><span class="n">compartment_from_node</span><span class="p">(</span><span class="n">G_limb</span><span class="p">,</span><span class="n">n</span><span class="p">),</span>
                                     <span class="n">skeletal_distance_to_soma</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">distance_upstream_from_soma</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="o">=</span><span class="n">n</span><span class="p">),</span>
                                   <span class="n">skeletal_length</span> <span class="o">=</span> <span class="n">G_limb</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;skeletal_length&quot;</span><span class="p">],</span>
                                    <span class="n">width</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">width_from_node</span><span class="p">(</span><span class="n">G_limb</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">branch_features_to_add</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">branch_features_to_add</span><span class="p">:</span>
                        <span class="n">curr_dt</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">G_limb</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
                        
                <span class="n">limb_dicts</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_dt</span>
                              
            
            
            <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">attribute</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">limb_dicts</span><span class="p">:</span>
                    <span class="n">limb_dicts</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="sa">f</span><span class="s2">&quot;n_</span><span class="si">{</span><span class="n">att</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">n_data_attribues</span><span class="p">(</span><span class="n">G_limb</span><span class="p">,</span><span class="n">attribute</span><span class="o">=</span><span class="n">att</span><span class="p">,</span><span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
                <span class="p">(</span><span class="n">inter_dict_att</span><span class="p">,</span>
                 <span class="n">upstream_dist</span><span class="p">)</span><span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">inter_attribute_intervals_from_G</span><span class="p">(</span>
                    <span class="n">G_limb</span><span class="p">,</span>
                    <span class="n">attribute</span><span class="o">=</span><span class="n">att</span><span class="p">,</span>
                    <span class="n">n_closest_neighbors</span><span class="o">=</span><span class="n">n_closest_neighbors</span><span class="p">,</span>
                    <span class="n">separate_branches</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                     <span class="n">return_upstream_dist</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="p">)</span>

                <span class="c1"># Add the attribute data to the dicts</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">data</span> <span class="ow">in</span> <span class="n">inter_dict_att</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">node_name</span><span class="p">,</span><span class="n">node_array</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">limb_dicts</span><span class="p">[</span><span class="n">node_name</span><span class="p">][</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">att</span><span class="si">}</span><span class="s2">_intervals_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_array</span>
                        
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">limb_dicts</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">limb_dicts</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">att</span><span class="si">}</span><span class="s2">_upstream_dist&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">upstream_dist</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>

            <span class="n">data_dicts</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">limb_dicts</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>


    <span class="k">return</span> <span class="n">data_dicts</span></div>



<span class="c1"># =============== For the random shuffling (6320)==================</span>
<div class="viewcode-block" id="shuffle_upstream_dist_on_data_attribute"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.shuffle_upstream_dist_on_data_attribute">[docs]</a><span class="k">def</span> <span class="nf">shuffle_upstream_dist_on_data_attribute</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">attribute</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">attribute_sk_nullification</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">exclude_presyn</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">discretization_length</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
    <span class="n">seed</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">plot_G</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: to randomly shuffle </span>
<span class="sd">    the upstream dists of data attributes</span>
<span class="sd">    in a neuron object (for null testing)</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    from neuron_morphology_tools from neurd import neuron_nx_utils as nxu</span>

<span class="sd">    segment_id = 864691134885060346</span>
<span class="sd">    split_index = 0</span>

<span class="sd">    plot = False</span>
<span class="sd">    plot_proofread_neuron = False</span>


<span class="sd">    G_obj = hdju.graph_obj_from_auto_proof_stage(</span>
<span class="sd">            segment_id=segment_id,</span>
<span class="sd">            split_index=split_index,</span>
<span class="sd">        )</span>

<span class="sd">    if plot:</span>
<span class="sd">        nxu.plot(G_obj)</span>

<span class="sd">    if plot_proofread_neuron:</span>
<span class="sd">        hdju.plot_proofread_neuron(</span>
<span class="sd">            segment_id,split_index,</span>
<span class="sd">        )</span>

<span class="sd">    G = nxu.inter_attribute_G_preprocessing(</span>
<span class="sd">        G,</span>
<span class="sd">        dendrite_only = dendrite_only,</span>
<span class="sd">        remove_starter_branches = dendrite_only,</span>
<span class="sd">    )</span>

<span class="sd">    limb_graphs,limb_idxs = nxu.all_limb_graphs(G,return_idxs=True)</span>

<span class="sd">    nxu.shuffle_upstream_dist_on_data_attribute(</span>
<span class="sd">        limb_graphs[0],</span>
<span class="sd">        verbose = True</span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">attribute_sk_nullification</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">attribute_sk_nullification</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">spines</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">attribute</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">attribute</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;spine&quot;</span><span class="p">,</span><span class="s1">&#39;synapse&#39;</span><span class="p">]</span>
        
    <span class="n">attribute</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">convert_to_array_like</span><span class="p">(</span><span class="n">attribute</span><span class="p">)</span>


    <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

    <span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">plot_G</span><span class="p">:</span>
        <span class="n">nxu</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;-- Working on node </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">----&quot;</span><span class="p">)</span>
        <span class="n">branch_dict</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

        <span class="c1">#1) Get the skeleton length</span>
        <span class="n">skeletal_length</span> <span class="o">=</span> <span class="n">branch_dict</span><span class="p">[</span><span class="s2">&quot;skeletal_length&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;skeletal_length = </span><span class="si">{</span><span class="n">skeletal_length</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


        <span class="c1">#2) Create an array like a skeleton</span>
        <span class="n">sk_array</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">arange_with_leftover</span><span class="p">(</span><span class="n">skeletal_length</span><span class="p">,</span><span class="n">step</span> <span class="o">=</span> <span class="n">discretization_length</span><span class="p">)</span>

<span class="c1">#         if verbose:</span>
<span class="c1">#             print(f&quot;sk_array = {sk_array}&quot;)</span>
            


        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">attribute</span><span class="p">:</span>
            <span class="c1">#a) gets the nullification distance</span>
            <span class="n">f_null</span> <span class="o">=</span> <span class="n">attribute_sk_nullification</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1">#b) Get the number of that feature to randomly sample</span>
            <span class="n">n_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;n_</span><span class="si">{</span><span class="n">f</span><span class="si">}</span><span class="s2">s&quot;</span>
            <span class="k">if</span> <span class="n">f</span> <span class="o">==</span> <span class="s2">&quot;synapse&quot;</span> <span class="ow">and</span> <span class="n">exclude_presyn</span><span class="p">:</span>
                <span class="n">n_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;n_</span><span class="si">{</span><span class="n">f</span><span class="si">}</span><span class="s2">s_post&quot;</span>
            <span class="n">n_feat</span> <span class="o">=</span> <span class="n">branch_dict</span><span class="p">[</span><span class="n">n_name</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">n_name</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">n_feat</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


            <span class="n">sk_array_curr</span> <span class="o">=</span> <span class="n">sk_array</span><span class="p">[(</span><span class="n">sk_array</span> <span class="o">&gt;=</span> <span class="n">f_null</span><span class="p">)</span>
                                    <span class="o">&amp;</span> <span class="p">(</span><span class="n">sk_array</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">sk_array</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">f_null</span><span class="p">))]</span>

        <span class="c1">#     if verbose:</span>
        <span class="c1">#         print(f&quot;sk_array_curr = {sk_array_curr}&quot;)</span>

            <span class="c1"># randomly sample from the distance array</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">randomly_sample_array</span><span class="p">(</span><span class="n">sk_array_curr</span><span class="p">,</span><span class="n">n_samples</span> <span class="o">=</span> <span class="n">n_feat</span><span class="p">,</span><span class="n">replace</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;samples = </span><span class="si">{</span><span class="n">sample</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># need to alter the upstream distances</span>
            <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">curr_dict</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">f</span><span class="si">}</span><span class="s2">_data&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">f</span> <span class="o">==</span> <span class="s2">&quot;synapse&quot;</span> <span class="ow">and</span> <span class="n">exclude_presyn</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">curr_dict</span><span class="p">[</span><span class="s2">&quot;syn_type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;presyn&quot;</span><span class="p">:</span>
                        <span class="k">continue</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping presyn&quot;</span><span class="p">)</span>
                <span class="n">curr_dict</span><span class="p">[</span><span class="s2">&quot;upstream_dist&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sample</span><span class="p">[</span><span class="n">counter</span><span class="p">]</span>
                <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>


    <span class="k">return</span> <span class="n">G</span></div>


<div class="viewcode-block" id="plot_inter_attribute_intervals_from_dicts"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.plot_inter_attribute_intervals_from_dicts">[docs]</a><span class="k">def</span> <span class="nf">plot_inter_attribute_intervals_from_dicts</span><span class="p">(</span>
    <span class="n">dicts</span><span class="p">,</span>
    <span class="n">attribute</span> <span class="o">=</span> <span class="s2">&quot;spine&quot;</span><span class="p">,</span>
    <span class="n">bins</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
    <span class="n">title</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">um</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">attributes_to_plot</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To plot a certain attributes from a list of </span>
<span class="sd">    datajoint dicts storing the distributions</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">attributes_to_plot</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dicts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">attribute</span><span class="si">}</span><span class="s2">_interval&quot;</span> <span class="ow">in</span> <span class="n">k</span><span class="p">]</span>


    <span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,)</span>

    <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">attributes_to_plot</span><span class="p">:</span>
        <span class="n">all_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">k</span><span class="p">[</span><span class="n">att</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dicts</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">att</span><span class="si">}</span><span class="s2"> mean = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">all_data</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">um</span><span class="p">:</span>
            <span class="n">all_data</span>  <span class="o">=</span> <span class="n">all_data</span><span class="o">/</span><span class="mi">1000</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">all_data</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="n">att</span><span class="p">,</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="n">bins</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Closest </span><span class="si">{</span><span class="n">attribute</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Distance (um)&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Count&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span></div>
        
<div class="viewcode-block" id="filter_graph"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.filter_graph">[docs]</a><span class="k">def</span> <span class="nf">filter_graph</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">remove_starter_branches</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">distance_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">distance_threshold_min</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">features_to_output</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">filter_away_soma</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">output_graph_type</span> <span class="o">=</span> <span class="s2">&quot;Graph&quot;</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To filter the graph object</span>
<span class="sd">    before the GNN processes</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Reduces to only dendrite subgraph</span>
<span class="sd">    2) Removes any small starter nodes</span>
<span class="sd">    3) Restricts to a certain distance</span>
<span class="sd">    4) Filter to certain features</span>
<span class="sd">    5) Filter into soma </span>
<span class="sd">    6) Turn into non-directed graph</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">verbose_soma_conn</span> <span class="o">=</span> <span class="kc">False</span>
    
    <span class="k">if</span> <span class="n">features_to_output</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">features_to_output</span> <span class="o">=</span> <span class="n">nxf</span><span class="o">.</span><span class="n">features_to_output_for_gnn</span>
    
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;L0_123&#39;</span> <span class="ow">in</span> <span class="n">G</span><span class="p">)</span>
    
    <span class="c1">#1) Reduces to only dendrite subgraph</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">dendrite_subgraph</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;L0_123&#39;</span> <span class="ow">in</span> <span class="n">G</span><span class="p">)</span>
            
    
    <span class="k">if</span> <span class="n">verbose_soma_conn</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Soma connected nodes = </span><span class="si">{</span><span class="n">nxu</span><span class="o">.</span><span class="n">soma_connected_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1">#2) Removes any small starter nodes</span>
    <span class="k">if</span> <span class="n">remove_starter_branches</span><span class="p">:</span>
        <span class="n">G_filt</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">remove_small_starter_branches</span><span class="p">(</span>
            <span class="n">G</span><span class="p">,</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
            <span class="n">maintain_skeleton_connectivity</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">G_filt</span> <span class="o">=</span> <span class="n">G</span>
        
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;L0_123&#39;</span> <span class="ow">in</span> <span class="n">G_filt</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">verbose_soma_conn</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After remove starter branches: Soma connected nodes = </span><span class="si">{</span><span class="n">nxu</span><span class="o">.</span><span class="n">soma_connected_nodes</span><span class="p">(</span><span class="n">G_filt</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="c1">#3) Restricts to a certain distance</span>
    <span class="k">if</span> <span class="n">distance_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">G_dist_filt</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">nodes_within_distance_upstream_from_soma</span><span class="p">(</span>
            <span class="n">G_filt</span><span class="p">,</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
            <span class="n">distance_threshold</span> <span class="o">=</span> <span class="n">distance_threshold</span><span class="p">,</span>
            <span class="n">return_subgraph</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">G_dist_filt</span> <span class="o">=</span> <span class="n">G_filt</span>
        
    <span class="k">if</span> <span class="n">verbose_soma_conn</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After dist threshold: Soma connected nodes = </span><span class="si">{</span><span class="n">nxu</span><span class="o">.</span><span class="n">soma_connected_nodes</span><span class="p">(</span><span class="n">G_dist_filt</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">distance_threshold_min</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">G_dist_filt</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">nodes_farther_than_distance_from_soma</span><span class="p">(</span>
            <span class="n">G_dist_filt</span><span class="p">,</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
            <span class="n">distance_threshold</span> <span class="o">=</span> <span class="n">distance_threshold_min</span><span class="p">,</span>
            <span class="n">return_subgraph</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">distance_type</span> <span class="o">=</span> <span class="s2">&quot;downstream&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        
    <span class="k">if</span> <span class="n">verbose_soma_conn</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After dist threshold min: Soma connected nodes = </span><span class="si">{</span><span class="n">nxu</span><span class="o">.</span><span class="n">soma_connected_nodes</span><span class="p">(</span><span class="n">G_dist_filt</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        

    <span class="c1">#4) Filter to certain features</span>
    <span class="k">if</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">nxu</span><span class="o">.</span><span class="n">limb_branch_subgraph</span><span class="p">(</span><span class="n">G_dist_filt</span><span class="p">)</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="ow">and</span> <span class="p">(</span><span class="n">features_to_output</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">features_to_output</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)):</span>
        
        <span class="n">G_with_feats</span> <span class="o">=</span> <span class="n">nxf</span><span class="o">.</span><span class="n">filter_G_features</span><span class="p">(</span>
                    <span class="n">G_dist_filt</span><span class="p">,</span>
                    <span class="n">features</span><span class="o">=</span><span class="n">features_to_output</span><span class="p">,</span>
                    <span class="n">inplace</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">G_with_feats</span> <span class="o">=</span> <span class="n">G_dist_filt</span>
    
    <span class="k">if</span> <span class="n">verbose_soma_conn</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After filter_G_features: Soma connected nodes = </span><span class="si">{</span><span class="n">nxu</span><span class="o">.</span><span class="n">soma_connected_nodes</span><span class="p">(</span><span class="n">G_dist_filt</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    
    <span class="k">if</span> <span class="n">filter_away_soma</span><span class="p">:</span>
        <span class="c1">#5) Filter into soma </span>
        <span class="n">G_no_soma</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">soma_filter_by_complete_graph</span><span class="p">(</span><span class="n">G_with_feats</span><span class="p">,</span><span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">G_no_soma</span> <span class="o">=</span> <span class="n">G_with_feats</span>
        
    <span class="c1">#6) Turn into non-directed graph</span>
    <span class="k">if</span> <span class="n">output_graph_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">G_no_soma</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">output_graph_type</span><span class="p">)(</span><span class="n">G_no_soma</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">G_no_soma</span></div>


<span class="c1"># --------- skeleton data ------------</span>
<div class="viewcode-block" id="skeleton_soma_to_limb_start"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.skeleton_soma_to_limb_start">[docs]</a><span class="k">def</span> <span class="nf">skeleton_soma_to_limb_start</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">soma_node_name_global</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">soma_node_name_global</span><span class="p">][</span><span class="s1">&#39;endpoint_upstream&#39;</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;endpoint_upstream&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span>
                   <span class="ow">in</span> <span class="n">nxu</span><span class="o">.</span><span class="n">soma_connected_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">)])</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">))])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">soma_node_name_global</span><span class="p">][</span><span class="s1">&#39;endpoint_upstream&#39;</span><span class="p">]])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">nodes</span><span class="p">,</span><span class="n">edges</span></div>

    

<div class="viewcode-block" id="skeleton"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.skeleton">[docs]</a><span class="k">def</span> <span class="nf">skeleton</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">include_soma</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">return_verts_edges</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
    
    <span class="n">skeleton_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="n">skeleton_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nxu</span><span class="o">.</span><span class="n">limb_branch_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
        
        <span class="n">curr_nodes</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;skeleton_data&quot;</span><span class="p">]</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_nodes</span><span class="p">))[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                          <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_nodes</span><span class="p">))[</span><span class="mi">1</span><span class="p">:],])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">edges</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">skeleton_nodes</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">skeleton_nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">skeleton_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">skeleton_nodes</span><span class="p">,</span><span class="n">curr_nodes</span><span class="p">])</span>
            <span class="n">skeleton_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">skeleton_edges</span><span class="p">,</span><span class="n">edges</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">skeleton_nodes</span> <span class="o">=</span> <span class="n">curr_nodes</span>
            <span class="n">skeleton_edges</span> <span class="o">=</span> <span class="n">edges</span>

    <span class="c1"># add on the soma edges if have them</span>
    <span class="k">if</span> <span class="n">include_soma</span> <span class="ow">and</span> <span class="n">soma_node_name_global</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
        <span class="n">soma_nodes</span><span class="p">,</span><span class="n">soma_edges</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">skeleton_soma_to_limb_start</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">soma_edges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">soma_edges</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">skeleton_nodes</span><span class="p">)</span>
        <span class="n">skeleton_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">skeleton_nodes</span><span class="p">,</span><span class="n">soma_nodes</span><span class="p">])</span>
        <span class="n">skeleton_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">skeleton_edges</span><span class="p">,</span><span class="n">soma_edges</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of nodes = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">skeleton_nodes</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of edges = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">skeleton_edges</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">new_figure</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_mesh</span><span class="p">(</span>
                <span class="n">mesh</span><span class="p">,</span>
                <span class="n">new_figure</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">show_at_end</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">flip_y</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.1</span>
            <span class="p">)</span>
            <span class="n">new_figure</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_obj</span><span class="p">(</span>
            <span class="n">array</span> <span class="o">=</span> <span class="n">skeleton_nodes</span><span class="p">,</span>
            <span class="n">lines</span><span class="o">=</span><span class="n">skeleton_edges</span><span class="p">,</span>
            <span class="n">flip_y</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">new_figure</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>

        <span class="p">)</span>
        
    
        
    <span class="k">if</span> <span class="n">return_verts_edges</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">skeleton_nodes</span><span class="p">,</span><span class="n">skeleton_edges</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">skeleton_nodes</span><span class="p">[</span><span class="n">skeleton_edges</span><span class="p">]</span></div>
    
<div class="viewcode-block" id="plot_skeleton"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.plot_skeleton">[docs]</a><span class="k">def</span> <span class="nf">plot_skeleton</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">mesh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">nxu</span><span class="o">.</span><span class="n">skeleton</span><span class="p">(</span>
        <span class="n">G</span><span class="p">,</span>
        <span class="n">plot</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="skeleton_nodes"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.skeleton_nodes">[docs]</a><span class="k">def</span> <span class="nf">skeleton_nodes</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">include_soma</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="n">nxu</span><span class="o">.</span><span class="n">skeleton</span><span class="p">(</span>
        <span class="n">G</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
        <span class="n">include_soma</span><span class="o">=</span><span class="n">include_soma</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>
    
    
<div class="viewcode-block" id="soma_center"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.soma_center">[docs]</a><span class="k">def</span> <span class="nf">soma_center</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">use_most_upstream_as_backup</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">soma_node_name_global</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">soma_node_name_global</span><span class="p">][</span><span class="s2">&quot;endpoint_upstream&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">nxu</span><span class="o">.</span><span class="n">most_upstream_node</span><span class="p">(</span><span class="n">G</span><span class="p">)][</span><span class="s2">&quot;endpoint_upstream&quot;</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>
        
        
<div class="viewcode-block" id="starting_coordinates_all_limbs"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.starting_coordinates_all_limbs">[docs]</a><span class="k">def</span> <span class="nf">starting_coordinates_all_limbs</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get all of the limb starting coordinates</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    2) Get all those bordering the soma</span>
<span class="sd">    3) Assemble the starting coordinates</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">soma_conn_nodes</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">soma_connected_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">soma_conn_nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">starting_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;endpoint_upstream&quot;</span><span class="p">]</span> 
                                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">soma_conn_nodes</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">starting_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;starting_coordinates = </span><span class="si">{</span><span class="n">starting_coordinates</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">starting_coordinates</span></div>

<div class="viewcode-block" id="skeleton_width_data_from_node"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.skeleton_width_data_from_node">[docs]</a><span class="k">def</span> <span class="nf">skeleton_width_data_from_node</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">n</span><span class="p">,</span>
    <span class="n">skeleton_midpoints</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">width_to_repeat</span> <span class="o">=</span> <span class="s2">&quot;last&quot;</span><span class="p">,</span>
    
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get the skeleton data and </span>
<span class="sd">    the width associated with each skeleton point</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">node_data</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

    <span class="n">skeleton_points</span> <span class="o">=</span> <span class="n">node_data</span><span class="p">[</span><span class="s2">&quot;skeleton_data&quot;</span><span class="p">]</span>
    <span class="n">width_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;width&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">node_data</span><span class="p">[</span><span class="s2">&quot;width_data&quot;</span><span class="p">]])</span>
    <span class="k">if</span> <span class="n">skeleton_midpoints</span><span class="p">:</span>
        <span class="n">skeleton_points</span> <span class="o">=</span> <span class="p">(</span><span class="n">skeleton_points</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">+</span><span class="n">skeleton_points</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">width_to_repeat</span> <span class="o">==</span> <span class="s2">&quot;last&quot;</span><span class="p">:</span>
            <span class="n">repeat_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="n">width_to_repeat</span> <span class="o">==</span> <span class="s2">&quot;first&quot;</span><span class="p">:</span>
            <span class="n">repeat_index</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">width_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">width_array</span><span class="p">,[</span><span class="n">width_array</span><span class="p">[</span><span class="n">repeat_index</span><span class="p">]]])</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">skeleton_points</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">width_array</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">skeleton_points</span><span class="p">,</span><span class="n">width_array</span></div>

<div class="viewcode-block" id="skeleton_width_compartment_arrays_from_G"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.skeleton_width_compartment_arrays_from_G">[docs]</a><span class="k">def</span> <span class="nf">skeleton_width_compartment_arrays_from_G</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">compartments</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">replace_underscore_in_compartments</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To extract the skeleton,width,compartment</span>
<span class="sd">    arrays from a neuron object</span>
<span class="sd">    </span>
<span class="sd">    segment_id = 864691136422863407</span>
<span class="sd">    split_index = 0</span>
<span class="sd">    G = hdju.graph_obj_from_proof_stage(segment_id,split_index)</span>
<span class="sd">    mesh = hdju.fetch_proofread_mesh(segment_id)</span>

<span class="sd">    nxu.skeleton_width_compartment_arrays_from_G(</span>
<span class="sd">        G,</span>
<span class="sd">        plot = True,</span>
<span class="sd">        mesh = mesh)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">skeleton_array</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">width_array</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">compartment_array</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nxu</span><span class="o">.</span><span class="n">limb_branch_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
        <span class="n">skel_data</span><span class="p">,</span><span class="n">width_data</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">skeleton_width_data_from_node</span><span class="p">(</span>
            <span class="n">G</span><span class="p">,</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">width_data</span> <span class="o">&gt;</span> <span class="mi">1000000</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="n">comp</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">compartment_from_node</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">replace_underscore</span><span class="o">=</span><span class="n">replace_underscore_in_compartments</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">compartments</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">comp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">compartments</span><span class="p">:</span>
                <span class="k">continue</span>
        <span class="n">comp_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">([</span><span class="n">comp</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">skel_data</span><span class="p">))</span>

        <span class="n">skeleton_array</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">skel_data</span><span class="p">)</span>
        <span class="n">width_array</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">width_data</span><span class="p">)</span>
        <span class="n">compartment_array</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comp_data</span><span class="p">)</span>

    <span class="n">skeleton_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">skeleton_array</span><span class="p">)</span>
    <span class="n">width_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">width_array</span><span class="p">)</span>
    <span class="n">compartment_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">compartment_array</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">new_figure</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_mesh</span> <span class="o">=</span> <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_mesh</span><span class="p">(</span>
                <span class="n">mesh</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
                <span class="n">flip_y</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                <span class="n">show_at_end</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">new_figure</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">new_figure</span> <span class="o">=</span> <span class="kc">False</span>
            
        <span class="n">scat_mesh</span> <span class="o">=</span> <span class="n">meshu</span><span class="o">.</span><span class="n">scatter_mesh_with_radius</span><span class="p">(</span><span class="n">skeleton_array</span><span class="p">,</span><span class="n">width_array</span><span class="p">)</span>
        <span class="n">new_mesh</span> <span class="o">=</span> <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_mesh</span><span class="p">(</span>
            <span class="n">scat_mesh</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span>
            <span class="n">flip_y</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">new_figure</span> <span class="o">=</span> <span class="n">new_figure</span><span class="p">,</span>
            <span class="n">show_at_end</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>        
        
    <span class="k">return</span> <span class="n">skeleton_array</span><span class="p">,</span><span class="n">width_array</span><span class="p">,</span><span class="n">compartment_array</span></div>


<div class="viewcode-block" id="nodes_between_soma_and_nodes"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.nodes_between_soma_and_nodes">[docs]</a><span class="k">def</span> <span class="nf">nodes_between_soma_and_nodes</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">nodes</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: to find the nodes in between a set of nodes</span>
<span class="sd">    and the soma node</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    nxu.nodes_between_soma_and_nodes(</span>
<span class="sd">        G_presyn,</span>
<span class="sd">        nodes=[&quot;L0_5&quot;,&quot;L0_7&quot;],</span>
<span class="sd">        verbose = True</span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s2">&quot;str&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">nodes</span><span class="p">)):</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">nxu</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">nodes</span><span class="si">}</span><span class="s2">_nodes&quot;</span><span class="p">)(</span><span class="n">G</span><span class="p">)</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">convert_to_array_like</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
    <span class="n">path</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">end_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">shortest_path_between_two_sets_of_nodes</span><span class="p">(</span>
        <span class="n">G</span><span class="p">,</span>
        <span class="p">[</span><span class="n">nxu</span><span class="o">.</span><span class="n">soma_node_name_global</span><span class="p">],</span>
        <span class="n">nodes</span><span class="p">,</span>

    <span class="p">)</span>

    <span class="n">in_between_nodes</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;in_between_nodes = </span><span class="si">{</span><span class="n">in_between_nodes</span><span class="si">}</span><span class="s2">, closest node to soma = </span><span class="si">{</span><span class="n">end_node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">in_between_nodes</span></div>

<div class="viewcode-block" id="compartment_nodes"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.compartment_nodes">[docs]</a><span class="k">def</span> <span class="nf">compartment_nodes</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">compartment</span><span class="p">,</span>
    <span class="n">include_path_to_soma</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ex: nxu.compartment_nodes(G_presyn,&quot;apical_shaft&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">compartment</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">convert_to_array_like</span><span class="p">(</span><span class="n">compartment</span><span class="p">)</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">nxu</span><span class="o">.</span><span class="n">limb_branch_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
        <span class="n">comp_reg</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">compartment_from_node</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">replace_underscore</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">comp</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">compartment_from_node</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">compartment</span><span class="p">,[</span><span class="n">comp_reg</span><span class="p">,</span><span class="n">comp</span><span class="p">]))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">compartment</span><span class="si">}</span><span class="s2"> nodes = </span><span class="si">{</span><span class="n">nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">include_path_to_soma</span><span class="p">:</span>
        <span class="n">new_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nxu</span><span class="o">.</span><span class="n">nodes_between_soma_and_nodes</span><span class="p">(</span>
            <span class="n">G</span><span class="p">,</span>
            <span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">,</span>
        <span class="p">))</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Non axon nodes added on path to soma = </span><span class="si">{</span><span class="n">new_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="n">nodes</span> <span class="o">+=</span> <span class="n">new_nodes</span>
        
    <span class="k">return</span> <span class="n">nodes</span></div>

<div class="viewcode-block" id="compartment_subgraph"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.compartment_subgraph">[docs]</a><span class="k">def</span> <span class="nf">compartment_subgraph</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">compartment</span><span class="p">,</span>
    <span class="n">include_path_to_soma</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get the axon skeleton</span>
<span class="sd">    (and optionally the skeleton in between axon and soma)</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">compartment_nodes</span><span class="p">(</span>
        <span class="n">G</span><span class="p">,</span><span class="n">compartment</span><span class="p">,</span><span class="n">include_path_to_soma</span><span class="o">=</span><span class="n">include_path_to_soma</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">compartment</span><span class="si">}</span><span class="s2"> nodes = </span><span class="si">{</span><span class="n">nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


    <span class="n">G_sub</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">G_sub</span></div>

<div class="viewcode-block" id="compartment_skeleton"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.compartment_skeleton">[docs]</a><span class="k">def</span> <span class="nf">compartment_skeleton</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">compartment</span><span class="p">,</span>
    <span class="n">include_path_to_soma</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">include_soma</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="n">sub_G</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">compartment_subgraph</span><span class="p">(</span>
        <span class="n">G</span><span class="p">,</span>
        <span class="n">compartment</span><span class="p">,</span>
        <span class="n">include_path_to_soma</span><span class="o">=</span><span class="n">include_path_to_soma</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
        <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">nxu</span><span class="o">.</span><span class="n">skeleton</span><span class="p">(</span>
        <span class="n">sub_G</span><span class="p">,</span>
        <span class="n">include_soma</span> <span class="o">=</span> <span class="n">include_soma</span><span class="p">,</span>
        <span class="n">plot</span> <span class="o">=</span> <span class="n">plot</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="axon_skeleton"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.axon_skeleton">[docs]</a><span class="k">def</span> <span class="nf">axon_skeleton</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">include_path_to_soma</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
    
    <span class="k">return</span> <span class="n">nxu</span><span class="o">.</span><span class="n">compartment_skeleton</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">compartment</span><span class="o">=</span><span class="s2">&quot;axon&quot;</span><span class="p">,</span>
    <span class="n">include_path_to_soma</span><span class="o">=</span><span class="n">include_path_to_soma</span><span class="p">,</span>
    <span class="n">include_soma</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="n">plot</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordinate_estimation_from_upstream_dist_from_node"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.coordinate_estimation_from_upstream_dist_from_node">[docs]</a><span class="k">def</span> <span class="nf">coordinate_estimation_from_upstream_dist_from_node</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">n</span><span class="p">,</span>
    <span class="n">attribute</span><span class="o">=</span> <span class="s2">&quot;spine_data&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To estimate the coordinates of the a data</span>
<span class="sd">    attribute with an upstream distance</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get the skeleton and calculate the distance between each</span>
<span class="sd">    2) Get the cumulative distance</span>
<span class="sd">    3) Find the two skeleton points it&#39;s in between</span>
<span class="sd">    4) Do a weighted average of the skeleton points after subtracting the cumulative distance</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    nxu.coordinate_estimation_from_upstream_dist_from_node(</span>
<span class="sd">        G_postsyn,</span>
<span class="sd">        &quot;L1_6&quot;</span>
<span class="sd">    ).shape</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s2">&quot;_data&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">attribute</span><span class="p">:</span>
        <span class="n">attribute</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">attribute</span><span class="si">}</span><span class="s2">_data&quot;</span>

    <span class="n">node_data</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="n">sk_verts</span> <span class="o">=</span> <span class="n">node_data</span><span class="p">[</span><span class="s2">&quot;skeleton_data&quot;</span><span class="p">]</span>
    <span class="n">spine_upstream</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;upstream_dist&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">node_data</span><span class="p">[</span><span class="s2">&quot;spine_data&quot;</span><span class="p">]])</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spine_upstream</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">sk_verts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">sk_verts</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">dists</span><span class="p">)])</span>

        <span class="n">highest_bound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">spine_upstream</span><span class="p">,</span><span class="n">bins</span><span class="p">)</span>
        <span class="n">highest_bound</span><span class="p">[</span><span class="n">highest_bound</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">highest_bound</span><span class="p">[</span><span class="n">highest_bound</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># do the weighted average of the to get the actual distance</span>
        <span class="n">dist_from_up</span> <span class="o">=</span> <span class="n">bins</span><span class="p">[</span><span class="n">highest_bound</span><span class="p">]</span> <span class="o">-</span> <span class="n">spine_upstream</span>
        <span class="n">dist_from_down</span> <span class="o">=</span> <span class="n">spine_upstream</span> <span class="o">-</span> <span class="n">bins</span><span class="p">[</span><span class="n">highest_bound</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="n">dist_from_up</span><span class="o">+</span><span class="n">dist_from_down</span>
        
        <span class="c1">#makes sure no zero denominator values</span>
        <span class="n">dist_from_up</span><span class="p">[</span><span class="n">denom</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">denom</span><span class="p">[</span><span class="n">denom</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">up_weight</span> <span class="o">=</span> <span class="n">dist_from_up</span><span class="o">/</span><span class="p">(</span><span class="n">dist_from_up</span><span class="o">+</span><span class="n">dist_from_down</span><span class="p">)</span>
        <span class="n">down_weight</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span> <span class="n">up_weight</span>

        <span class="n">spine_shaft_coords</span> <span class="o">=</span> <span class="n">sk_verts</span><span class="p">[</span><span class="n">highest_bound</span><span class="p">]</span><span class="o">*</span><span class="n">up_weight</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">sk_verts</span><span class="p">[</span><span class="n">highest_bound</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">down_weight</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">spine_shaft_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">spine_shaft_coords</span></div>

    
<span class="c1"># purpose: Get the spine data in the area</span>
<div class="viewcode-block" id="spine_shaft_coordinates"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.spine_shaft_coordinates">[docs]</a><span class="k">def</span> <span class="nf">spine_shaft_coordinates</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Get all of the spine coordinates (located on the shaft)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">spine_coordinates</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nxu</span><span class="o">.</span><span class="n">limb_branch_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
        <span class="n">spine_coordinates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">nxu</span><span class="o">.</span><span class="n">coordinate_estimation_from_upstream_dist_from_node</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="n">spine_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">spine_coordinates</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of spine coordinates = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">spine_coordinates</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">new_figure</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_mesh</span><span class="p">(</span>
                <span class="n">mesh</span><span class="p">,</span>
                <span class="n">new_figure</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">show_at_end</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">flip_y</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.25</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">new_figure</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_obj</span><span class="p">(</span>
            <span class="n">array</span> <span class="o">=</span> <span class="n">spine_coordinates</span><span class="p">,</span>
            <span class="n">flip_y</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">new_figure</span> <span class="o">=</span> <span class="n">new_figure</span><span class="p">,</span>
        <span class="p">)</span>
        
    <span class="k">return</span> <span class="n">spine_coordinates</span></div>

<div class="viewcode-block" id="most_upstream_node_on_axon_limb"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.most_upstream_node_on_axon_limb">[docs]</a><span class="k">def</span> <span class="nf">most_upstream_node_on_axon_limb</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">return_endpoint_upstream</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>

    <span class="n">node</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">most_upstream_node</span><span class="p">(</span>
        <span class="n">G</span><span class="p">,</span>
        <span class="n">nxu</span><span class="o">.</span><span class="n">compartment_nodes</span><span class="p">(</span>
        <span class="n">G</span><span class="p">,</span>
        <span class="n">compartment</span><span class="o">=</span><span class="s2">&quot;axon&quot;</span><span class="p">,</span>
        <span class="n">include_path_to_soma</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
    <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Most upstream node on axon branch = </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_endpoint_upstream</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;endpoint_upstream&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">node</span></div>
    
<div class="viewcode-block" id="skeleton_graph"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.skeleton_graph">[docs]</a><span class="k">def</span> <span class="nf">skeleton_graph</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">graph_type</span><span class="o">=</span><span class="s2">&quot;Graph&quot;</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">mesh_tools</span> <span class="kn">import</span> <span class="n">skeleton_utils</span> <span class="k">as</span> <span class="n">sk</span>
    <span class="n">verts</span><span class="p">,</span><span class="n">edges</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">skeleton</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sk</span><span class="o">.</span><span class="n">graph_from_non_unique_vertices_edges</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span><span class="n">edges</span><span class="p">)</span></div>

<div class="viewcode-block" id="fix_attribute"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.fix_attribute">[docs]</a><span class="k">def</span> <span class="nf">fix_attribute</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
        <span class="n">attribute</span><span class="o">=</span><span class="s2">&quot;spine&quot;</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    
    <span class="n">attribute</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">convert_to_array_like</span><span class="p">(</span><span class="n">attribute</span><span class="p">)</span>
        
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
        <span class="k">if</span> <span class="s2">&quot;s&quot;</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
            <span class="k">continue</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">attribute</span><span class="p">:</span>
            <span class="n">f_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;n_</span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s2">s&quot;</span>
            <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">f_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s2">_data&quot;</span><span class="p">,[]))</span>

    <span class="k">return</span> <span class="n">G</span></div>

<div class="viewcode-block" id="fix_flipped_skeleton"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.fix_flipped_skeleton">[docs]</a><span class="k">def</span> <span class="nf">fix_flipped_skeleton</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To fix the skeleton data</span>
<span class="sd">    in Graph objects if they are</span>
<span class="sd">    not aligned correctly</span>

<span class="sd">    Ex: </span>
<span class="sd">    segment_id,split_index = 864691135162621741,0</span>

<span class="sd">    G_obj = hdju.graph_obj_from_auto_proof_stage(</span>
<span class="sd">        segment_id=segment_id,</span>
<span class="sd">        split_index=split_index,</span>
<span class="sd">    )</span>

<span class="sd">    G_obj = fix_flipped_skeletons(G_obj,verbose = True)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">node_flipped</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
        <span class="k">if</span> <span class="s2">&quot;s&quot;</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
            <span class="k">continue</span>
        <span class="n">curr_dict</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_dict</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">endpt_up</span> <span class="o">=</span> <span class="n">curr_dict</span><span class="p">[</span><span class="s2">&quot;endpoint_upstream&quot;</span><span class="p">]</span>
        <span class="n">sk_up</span> <span class="o">=</span> <span class="n">curr_dict</span><span class="p">[</span><span class="s2">&quot;skeleton_data&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">endpt_up</span><span class="p">,</span><span class="n">sk_up</span><span class="p">):</span>
            <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;skeleton_data&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">curr_dict</span><span class="p">[</span><span class="s2">&quot;skeleton_data&quot;</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">node_flipped</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Nodes with skeleton flipped: </span><span class="si">{</span><span class="n">node_flipped</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">G</span></div>


<div class="viewcode-block" id="upstream_limb_branch"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.upstream_limb_branch">[docs]</a><span class="k">def</span> <span class="nf">upstream_limb_branch</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
    <span class="n">up_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">upstream_node</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="s2">&quot;S&quot;</span> <span class="ow">in</span> <span class="n">up_node</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">up_node</span></div>
    
<div class="viewcode-block" id="downstream_limb_branch"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.downstream_limb_branch">[docs]</a><span class="k">def</span> <span class="nf">downstream_limb_branch</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
    <span class="n">d_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">downstream_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">d_node</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">d_node</span></div>
    
<div class="viewcode-block" id="fix_width_inf_nan"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.fix_width_inf_nan">[docs]</a><span class="k">def</span> <span class="nf">fix_width_inf_nan</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">default_value</span> <span class="o">=</span> <span class="mi">300</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,):</span>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: to replace all inf width values in node</span>
<span class="sd">    with either the upstream, downstream width, or default value</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1a) Try and get an upstream width</span>
<span class="sd">    1b) Try and get a downstream width</span>
<span class="sd">    1c) Use the default width</span>
<span class="sd">    2) Go and replace all width values and in the width array</span>
<span class="sd">    with the default value</span>

<span class="sd">    Width values to replace: </span>
<span class="sd">    - width (scalar)</span>
<span class="sd">    - width_new (a dictionary)</span>
<span class="sd">    - width_upstream (scalar)</span>
<span class="sd">    - width_downstream (scalar)</span>
<span class="sd">    - width_data: list of dict with width as key</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nodes_fixed</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nxu</span><span class="o">.</span><span class="n">limb_branch_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">curr_wid</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;width&quot;</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_nan_or_inf</span><span class="p">(</span><span class="n">curr_wid</span><span class="p">):</span>
            <span class="n">nodes_fixed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="c1">#1a) Try and get an upstream width</span>
            <span class="n">up_node</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">upstream_limb_branch</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
            <span class="n">new_width</span> <span class="o">=</span> <span class="n">default_value</span>
            <span class="k">if</span> <span class="n">up_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">new_width</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">up_node</span><span class="p">][</span><span class="s2">&quot;width_new&quot;</span><span class="p">][</span><span class="s2">&quot;no_spine_median_mesh_center&quot;</span><span class="p">]</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">d_nodes</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">downstream_limb_branch</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">d_nodes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">new_width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;width_new&quot;</span><span class="p">][</span><span class="s2">&quot;no_spine_median_mesh_center&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">d_nodes</span><span class="p">])</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="k">pass</span>

            <span class="c1"># do the replacement of all the width values</span>
            <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;width&quot;</span><span class="p">]</span> <span class="o">=</span><span class="n">new_width</span>
            <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;width_new&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">new_width</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;width_new&quot;</span><span class="p">]}</span>
            <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;width_upstream&quot;</span><span class="p">]</span> <span class="o">=</span><span class="n">new_width</span>
            <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;width_downstream&quot;</span><span class="p">]</span> <span class="o">=</span><span class="n">new_width</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;width_data&quot;</span><span class="p">]:</span>
                <span class="n">k</span><span class="p">[</span><span class="s2">&quot;width&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_width</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nodes_fixed = </span><span class="si">{</span><span class="n">nodes_fixed</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">G</span>  </div>


<div class="viewcode-block" id="soma_vector_from_node"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.soma_vector_from_node">[docs]</a><span class="k">def</span> <span class="nf">soma_vector_from_node</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">n</span><span class="p">,</span>
    <span class="n">soma_coordinate</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">normalize</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>  
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get the angle between a node</span>
<span class="sd">    and the soma a node</span>
<span class="sd">    </span>
<span class="sd">    Ex:</span>
<span class="sd">    nxu.soma_vector_from_node(</span>
<span class="sd">        G = G,</span>
<span class="sd">        soma_coordinate = None,</span>
<span class="sd">        normalize = True,</span>
<span class="sd">        n = &quot;L0_0&quot;,</span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">soma_coordinate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">soma_coordinate</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">soma_center</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

    <span class="n">soma_vector</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;endpoint_upstream&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">soma_coordinate</span>
    <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
        <span class="n">soma_vector</span> <span class="o">=</span> <span class="n">soma_vector</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">soma_vector</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;soma_vector = </span><span class="si">{</span><span class="n">soma_vector</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">soma_vector</span></div>

<div class="viewcode-block" id="skeleton_vector_upstream_and_width_from_node"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.skeleton_vector_upstream_and_width_from_node">[docs]</a><span class="k">def</span> <span class="nf">skeleton_vector_upstream_and_width_from_node</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">n</span><span class="p">,</span>
    <span class="n">upstream_dist_max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#np.inf</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_width</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get the skeleton vector of a node pointing in downstream</span>
<span class="sd">    (and may be restricted by certain downstream distance)</span>

<span class="sd">    - can return the associated width</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Find the n_idx to restrict to for the downstream dist</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    nxu.skeleton_vector_upstream_and_width_from_node(</span>
<span class="sd">        G = G_limbs[0],</span>
<span class="sd">        n = &quot;L0_22&quot;,</span>
<span class="sd">        upstream_dist_max = 3000,#np.inf</span>
<span class="sd">        verbose = True,</span>
<span class="sd">        return_width = True,</span>

<span class="sd">    )</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">upstream_dist_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">upstream_dist_max</span> <span class="o">=</span> <span class="n">default_upstream_dist_max</span>
    
    <span class="n">node_data</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

    <span class="n">idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">node_data</span><span class="p">[</span><span class="s2">&quot;width_data&quot;</span><span class="p">]</span>
              <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="s2">&quot;upstream_dist&quot;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">upstream_dist_max</span><span class="p">]</span>
    <span class="n">max_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;max_idx = </span><span class="si">{</span><span class="n">max_idx</span><span class="si">}</span><span class="s2"> (out of </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">node_data</span><span class="p">[</span><span class="s1">&#39;width_data&#39;</span><span class="p">])</span><span class="si">}</span><span class="s2"> nodes)&quot;</span><span class="p">)</span>

    <span class="n">skeleton_nodes</span> <span class="o">=</span> <span class="n">node_data</span><span class="p">[</span><span class="s2">&quot;skeleton_data&quot;</span><span class="p">][:</span><span class="n">max_idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">skeleton_vector</span> <span class="o">=</span> <span class="n">skeleton_nodes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">-</span> <span class="n">skeleton_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
    <span class="n">skeleton_vector</span> <span class="o">=</span> <span class="n">skeleton_vector</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">skeleton_vector</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;skeleton_vector = </span><span class="si">{</span><span class="n">skeleton_vector</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># find the width associated with the skeleton</span>
    <span class="n">skeleton_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">skeleton_nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">-</span><span class="n">skeleton_nodes</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">widths</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;width&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">node_data</span><span class="p">[</span><span class="s2">&quot;width_data&quot;</span><span class="p">][:</span><span class="n">max_idx</span><span class="p">]]</span>

    <span class="n">weighted_width</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">weighted_average</span><span class="p">(</span><span class="n">widths</span><span class="p">,</span><span class="n">skeleton_lengths</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;widths = </span><span class="si">{</span><span class="n">widths</span><span class="si">}</span><span class="s2">, skeletal_seg_lengths = </span><span class="si">{</span><span class="n">skeleton_lengths</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;weighted_width = </span><span class="si">{</span><span class="n">weighted_width</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_width</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">skeleton_vector</span><span class="p">,</span><span class="n">weighted_width</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">skeleton_vector</span></div>
    
    
<div class="viewcode-block" id="most_upstream_node_vector_stats"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.most_upstream_node_vector_stats">[docs]</a><span class="k">def</span> <span class="nf">most_upstream_node_vector_stats</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">soma_coordinate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">most_upstream_node</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">upstream_dist_max</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: to compute the soma and skeleton</span>
<span class="sd">    vector and other statitistics about the</span>
<span class="sd">    most upstream node on a graph</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">return_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">upstream_dist_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">upstream_dist_max</span> <span class="o">=</span> <span class="n">default_upstream_dist_max</span>
    
    <span class="n">subG</span> <span class="o">=</span> <span class="n">G</span>
    <span class="k">if</span> <span class="n">most_upstream_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">most_upstream_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">most_upstream_node</span><span class="p">(</span><span class="n">subG</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    most_upstream_node = </span><span class="si">{</span><span class="n">most_upstream_node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        

    <span class="c1"># a) Determine the soma vector</span>
    
    <span class="n">soma_coord_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">soma_coordinate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">soma_vector</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">soma_vector_from_node</span><span class="p">(</span>
            <span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="p">,</span>
            <span class="n">soma_coordinate</span> <span class="o">=</span> <span class="n">soma_coordinate</span><span class="p">,</span>
            <span class="n">normalize</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">most_upstream_node</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;soma_vector = </span><span class="si">{</span><span class="n">soma_vector</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="n">soma_coord_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">soma_vector_x_nm</span> <span class="o">=</span> <span class="n">soma_vector</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">soma_vector_y_nm</span> <span class="o">=</span> <span class="n">soma_vector</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">soma_vector_z_nm</span> <span class="o">=</span> <span class="n">soma_vector</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
        <span class="p">)</span>
        


    <span class="c1"># b) Determine the skeleton vector</span>
    <span class="n">skeleton_vector</span><span class="p">,</span><span class="n">width</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">skeleton_vector_upstream_and_width_from_node</span><span class="p">(</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="p">,</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">most_upstream_node</span><span class="p">,</span>
        <span class="n">upstream_dist_max</span> <span class="o">=</span> <span class="n">upstream_dist_max</span><span class="p">,</span><span class="c1">#np.inf</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_width</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>

    <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;skeleton_vector = </span><span class="si">{</span><span class="n">skeleton_vector</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;width = </span><span class="si">{</span><span class="n">width</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">most_upstream_node</span>
    <span class="n">return_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">node</span><span class="o">=</span><span class="n">most_upstream_node</span><span class="p">,</span>
        <span class="n">endpoint_upstream_x_nm</span><span class="o">=</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;endpoint_upstream&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">endpoint_upstream_y_nm</span><span class="o">=</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;endpoint_upstream&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">endpoint_upstream_z_nm</span><span class="o">=</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;endpoint_upstream&quot;</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span>
        <span class="n">endpoint_downstream_x_nm</span><span class="o">=</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;endpoint_downstream&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">endpoint_downstream_y_nm</span><span class="o">=</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;endpoint_downstream&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">endpoint_downstream_z_nm</span><span class="o">=</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;endpoint_downstream&quot;</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span>
        <span class="n">skeleton_vector_x_nm</span> <span class="o">=</span> <span class="n">skeleton_vector</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">skeleton_vector_y_nm</span> <span class="o">=</span> <span class="n">skeleton_vector</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">skeleton_vector_z_nm</span> <span class="o">=</span> <span class="n">skeleton_vector</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
        <span class="n">width</span> <span class="o">=</span> <span class="n">width</span><span class="p">,</span>

    <span class="p">)</span>
    
    <span class="n">return_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">soma_coord_dict</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">return_dict</span></div>

<span class="c1"># def skeletal_length_on_G(</span>
<span class="c1">#     G,</span>
<span class="c1">#     ):</span>
<span class="c1">#     return np.sum([G.nodes[k][&quot;skeletal_length&quot;] for k in G.nodes()])</span>

<div class="viewcode-block" id="adjusted_scholl_coordinates"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.adjusted_scholl_coordinates">[docs]</a><span class="k">def</span> <span class="nf">adjusted_scholl_coordinates</span><span class="p">(</span>
    <span class="n">array</span><span class="p">,</span>
    <span class="n">soma_coordinate</span><span class="p">,</span>
    <span class="n">upstream_endpoint</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
    
    <span class="n">adjusted_offset</span> <span class="o">=</span> <span class="n">upstream_endpoint</span> <span class="o">-</span> <span class="n">soma_coordinate</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Adjusted offset = </span><span class="si">{</span><span class="n">adjusted_offset</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">array</span> <span class="o">-</span> <span class="n">adjusted_offset</span>
    <span class="k">return</span> <span class="n">array</span></div>

<div class="viewcode-block" id="scholl_coordinates"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.scholl_coordinates">[docs]</a><span class="k">def</span> <span class="nf">scholl_coordinates</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">soma_coordinate</span><span class="p">,</span>
    <span class="n">axes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">interval</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">max_distance</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_dict</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">adjusted</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: to calculate the coordinates</span>
<span class="sd">    of the skeleton that are interval distances</span>
<span class="sd">    away from the soma center</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Calculate the intervals will measure at based</span>
<span class="sd">    on max_distance or max of the G skeleton</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">interval</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">interval</span> <span class="o">=</span> <span class="n">default_scholl_interval</span>
    
    <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
    
    <span class="k">if</span> <span class="s2">&quot;np&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">G</span><span class="p">)):</span>
        <span class="n">skeleton</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">skeleton</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">return_verts_edges</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">adjusted</span><span class="p">:</span>
        <span class="n">upstream_endpoint</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">most_upstream_coordinate</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="n">skeleton</span> <span class="o">=</span> <span class="n">adjusted_scholl_coordinates</span><span class="p">(</span>
            <span class="n">skeleton</span><span class="p">,</span>
            <span class="n">soma_coordinate</span> <span class="o">=</span> <span class="n">soma_coordinate</span><span class="p">,</span>
            <span class="n">upstream_endpoint</span><span class="o">=</span><span class="n">upstream_endpoint</span><span class="p">,</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span>
<span class="c1">#         upstream_endpoint = nxu.most_upstream_coordinate(G)</span>
<span class="c1">#         adjusted_offset = upstream_endpoint - soma_coordinate</span>
<span class="c1">#         if verbose:</span>
<span class="c1">#             print(f&quot;Adjusted offset = {adjusted_offset}&quot;)</span>
<span class="c1">#         skeleton = skeleton - adjusted_offset</span>
        
    <span class="c1"># limiting the skeleton and center to certain axes</span>
    <span class="n">skeleton_axes</span> <span class="o">=</span> <span class="n">skeleton</span><span class="p">[:,:,</span><span class="n">axes</span><span class="p">]</span>
    <span class="n">soma_center_axes</span> <span class="o">=</span> <span class="n">soma_coordinate</span><span class="p">[</span><span class="n">axes</span><span class="p">]</span>
    
        
    <span class="k">if</span> <span class="n">max_distance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">skeleton_axes</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">))</span><span class="o">-</span><span class="n">soma_center_axes</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;max_distance computed = </span><span class="si">{</span><span class="n">max_distance</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
    <span class="n">radius_intervals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">max_distance</span><span class="o">+</span><span class="mf">0.0001</span><span class="p">,</span><span class="n">interval</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;radius_intervals = </span><span class="si">{</span><span class="n">radius_intervals</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="n">data_points</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">k</span><span class="p">:</span><span class="n">nsku</span><span class="o">.</span><span class="n">cirle_intersections</span><span class="p">(</span>
            <span class="n">skeleton</span><span class="p">,</span>
            <span class="n">soma_coordinate</span><span class="p">,</span>
            <span class="n">radius</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
            <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
            <span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">radius_intervals</span>
    <span class="p">}</span>
    
    <span class="k">if</span> <span class="n">adjusted</span><span class="p">:</span>
        <span class="n">data_points</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="o">+</span> <span class="n">adjusted_offset</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">data_points</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
    
    <span class="k">if</span> <span class="n">return_dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">data_points</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">data_points</span><span class="o">.</span><span class="n">values</span><span class="p">())</span></div>
    
<div class="viewcode-block" id="vector_stats_from_G"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.vector_stats_from_G">[docs]</a><span class="k">def</span> <span class="nf">vector_stats_from_G</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">soma_coordinate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">upstream_dist_max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">include_scholl_coordinates</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">include_scholl_coordinates_adjusted</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">include_bbox</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">include_internal_branching</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">include_n_scholl</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">plot_scholl</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To compute the following statistics for </span>
<span class="sd">    a subgraph of a neuron object</span>

<span class="sd">    a. starting width</span>
<span class="sd">    b. starting y above the soma</span>
<span class="sd">    c. soma angle</span>
<span class="sd">    d. skeletal angle</span>
<span class="sd">    e. skeletal length</span>
<span class="sd">    f. starting endpoint</span>
<span class="sd">    g. intersection points of skeleton </span>
<span class="sd">    (for as far as can go or max distance)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">upstream_dist_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">upstream_dist_max</span> <span class="o">=</span> <span class="n">default_upstream_dist_max</span>
    
    <span class="n">skeletal_length</span> <span class="o">=</span> <span class="n">nsku</span><span class="o">.</span><span class="n">skeletal_length</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="n">most_upstream_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">most_upstream_node</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;most_upstream_node = </span><span class="si">{</span><span class="n">most_upstream_node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">curr_dict</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">most_upstream_node_vector_stats</span><span class="p">(</span>
        <span class="n">G</span><span class="o">=</span><span class="n">G</span><span class="p">,</span>
        <span class="n">most_upstream_node</span><span class="o">=</span><span class="n">most_upstream_node</span><span class="p">,</span>
        <span class="n">soma_coordinate</span><span class="o">=</span><span class="n">soma_coordinate</span><span class="p">,</span>
        <span class="n">upstream_dist_max</span><span class="o">=</span><span class="n">upstream_dist_max</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="n">curr_dict</span><span class="p">[</span><span class="s2">&quot;skeletal_length&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">skeletal_length</span>
    <span class="k">if</span> <span class="n">soma_coordinate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">curr_dict</span><span class="p">[</span><span class="s2">&quot;y_soma_relative&quot;</span><span class="p">]</span> <span class="o">=</span>  <span class="n">curr_dict</span><span class="p">[</span><span class="s2">&quot;endpoint_upstream_y_nm&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">soma_coordinate</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">curr_dict</span><span class="p">[</span><span class="s2">&quot;n_nodes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
    
    
    <span class="n">leaf_nodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">leaf_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="n">curr_dict</span><span class="p">[</span><span class="s2">&quot;leaf_nodes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">leaf_nodes</span>
    <span class="n">curr_dict</span><span class="p">[</span><span class="s2">&quot;n_leaf_nodes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">leaf_nodes</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">include_scholl_coordinates</span> <span class="ow">and</span> <span class="n">soma_coordinate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">curr_dict</span><span class="p">[</span><span class="s2">&quot;scholl_coords&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">scholl_coordinates</span><span class="p">(</span>
            <span class="n">G</span><span class="p">,</span>
            <span class="n">soma_coordinate</span><span class="o">=</span><span class="n">soma_coordinate</span><span class="p">,</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="n">plot_scholl</span><span class="p">,</span>
            <span class="n">plot</span> <span class="o">=</span> <span class="n">plot_scholl</span><span class="p">,</span>
            <span class="n">adjusted</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        
        <span class="k">if</span> <span class="n">include_n_scholl</span><span class="p">:</span>
            <span class="n">curr_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="n">n_scholl_dict_from_scholl_dict</span><span class="p">(</span>
                    <span class="n">curr_dict</span><span class="p">[</span><span class="s2">&quot;scholl_coords&quot;</span><span class="p">],</span>
                    <span class="n">prefix</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                <span class="p">)</span>
            <span class="p">)</span>
        
    <span class="k">if</span> <span class="n">include_scholl_coordinates_adjusted</span> <span class="ow">and</span> <span class="n">soma_coordinate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">curr_dict</span><span class="p">[</span><span class="s2">&quot;scholl_coords_adjusted&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">scholl_coordinates</span><span class="p">(</span>
            <span class="n">G</span><span class="p">,</span>
            <span class="n">soma_coordinate</span><span class="o">=</span><span class="n">soma_coordinate</span><span class="p">,</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="n">plot_scholl</span><span class="p">,</span>
            <span class="n">plot</span> <span class="o">=</span> <span class="n">plot_scholl</span><span class="p">,</span>
            <span class="n">adjusted</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        
        <span class="k">if</span> <span class="n">include_n_scholl</span><span class="p">:</span>
            <span class="n">curr_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="n">n_scholl_dict_from_scholl_dict</span><span class="p">(</span>
                    <span class="n">curr_dict</span><span class="p">[</span><span class="s2">&quot;scholl_coords_adjusted&quot;</span><span class="p">],</span>
                    <span class="n">prefix</span> <span class="o">=</span> <span class="s2">&quot;_adjusted&quot;</span>
                <span class="p">)</span>
            <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">include_internal_branching</span><span class="p">:</span>
        <span class="n">curr_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">nxu</span><span class="o">.</span><span class="n">internal_branching_stats</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>
        
    <span class="k">if</span> <span class="n">include_bbox</span><span class="p">:</span>
        <span class="n">curr_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">nxu</span><span class="o">.</span><span class="n">skeleton_bbox</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">return_dict</span> <span class="o">=</span> <span class="kc">True</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="n">curr_dict</span></div>



        

<div class="viewcode-block" id="compartment_vector_width_stats_from_G"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.compartment_vector_width_stats_from_G">[docs]</a><span class="k">def</span> <span class="nf">compartment_vector_width_stats_from_G</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">small_starter_branch_skeletal_length_min</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
    <span class="n">upstream_dist_max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">min_skeletal_length_limb</span> <span class="o">=</span> <span class="mi">10_000</span><span class="p">,</span><span class="c1">#50_000,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To determine the max vector</span>
<span class="sd">    and weighted vector of all the compartments of a neuron</span>

<span class="sd">    1) Download the neuron graph</span>
<span class="sd">    2) Filter the neuron graph for small starter branches</span>
<span class="sd">    3) For each limb and then for each compartment:</span>
<span class="sd">        a. Find if nodes exist with that label</span>
<span class="sd">        b. Find the most upstream node</span>
<span class="sd">        c. Determine the width of that node (using the width data and upstream search distance)</span>
<span class="sd">        d. Save off the soma starting angle of that branch and the current skeleton angle and width</span>

<span class="sd">    4) For each compartment:</span>
<span class="sd">        a. Find the soma starting vector and skeleton vector of the weighted options (weight by width_max and width)</span>

<span class="sd">    5) Save off curr data to datajoint for each compartment:</span>
<span class="sd">    - angles (max and not max)</span>
<span class="sd">    - n_limbs in compartment</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">upstream_dist_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">upstream_dist_max</span> <span class="o">=</span> <span class="n">default_upstream_dist_max</span>
    
    
    <span class="n">G_filt</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">remove_small_starter_branches</span><span class="p">(</span>
                <span class="n">G</span><span class="p">,</span>
                <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                <span class="n">skeletal_length_min</span><span class="o">=</span><span class="n">small_starter_branch_skeletal_length_min</span><span class="p">,</span>
                <span class="n">maintain_skeleton_connectivity</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">soma_coordinate</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">soma_center</span><span class="p">(</span><span class="n">G_filt</span><span class="p">)</span>

    <span class="n">compartments</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;axon&quot;</span><span class="p">,</span><span class="s2">&quot;dendrite&quot;</span><span class="p">,</span><span class="s2">&quot;apicalshaft&quot;</span><span class="p">,</span><span class="s2">&quot;basal&quot;</span><span class="p">]</span>
    <span class="n">comp_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:[]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">compartments</span><span class="p">}</span>



    <span class="n">G_limbs</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">all_limb_graphs_off_soma</span><span class="p">(</span><span class="n">G_filt</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">limb</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">G_limbs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;---Working on limb </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">---&quot;</span><span class="p">)</span>


        <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">compartments</span><span class="p">:</span>
            <span class="n">subG</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">compartment_subgraph</span><span class="p">(</span><span class="n">limb</span><span class="p">,</span><span class="n">comp</span><span class="p">)</span>

            <span class="c1"># check if any nodes with that label</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subG</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">comp</span> <span class="o">==</span> <span class="s1">&#39;apicalshaft&#39;</span><span class="p">:</span>
                <span class="n">subG</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">compartment_subgraph</span><span class="p">(</span><span class="n">limb</span><span class="p">,</span><span class="s2">&quot;apical&quot;</span><span class="p">)</span>


            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subG</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No </span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2"> nodes in subgraph&quot;</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of </span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2"> nodes = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">subG</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">most_upstream_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">most_upstream_node</span><span class="p">(</span><span class="n">subG</span><span class="p">)</span>
            <span class="n">G_downstream</span> <span class="o">=</span> <span class="n">limb</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">xu</span><span class="o">.</span><span class="n">all_downstream_nodes</span><span class="p">(</span>
                 <span class="n">limb</span><span class="p">,</span>
                <span class="n">most_upstream_node</span><span class="p">,</span>
                <span class="n">include_self</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">))</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="n">limb_skeletal_length</span> <span class="o">=</span> <span class="n">nsku</span><span class="o">.</span><span class="n">skeletal_length</span><span class="p">(</span><span class="n">G_downstream</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;limb_skeletal_length = </span><span class="si">{</span><span class="n">limb_skeletal_length</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">limb_skeletal_length</span> <span class="o">&lt;</span> <span class="n">min_skeletal_length_limb</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   *** skipping limb </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2"> because skeletal_length (</span><span class="si">{</span><span class="n">limb_skeletal_length</span><span class="si">}</span><span class="s2">)&quot;</span>
                         <span class="sa">f</span><span class="s2">&quot; was less than minimum (</span><span class="si">{</span><span class="n">min_skeletal_length_limb</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="n">curr_dict</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">most_upstream_node_vector_stats</span><span class="p">(</span>
                <span class="n">G</span><span class="o">=</span><span class="n">subG</span><span class="p">,</span>
                <span class="n">most_upstream_node</span><span class="o">=</span><span class="n">most_upstream_node</span><span class="p">,</span>
                <span class="n">soma_coordinate</span><span class="o">=</span><span class="n">soma_coordinate</span><span class="p">,</span>
                <span class="n">upstream_dist_max</span><span class="o">=</span><span class="n">upstream_dist_max</span><span class="p">,</span>
                <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                <span class="p">)</span>
            
            <span class="n">curr_dict</span><span class="p">[</span><span class="s2">&quot;skeletal_length&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">limb_skeletal_length</span>

            <span class="n">comp_dict</span><span class="p">[</span><span class="n">comp</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_dict</span><span class="p">)</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: For each compartment:</span>
<span class="sd">        a. Find the soma starting vector and skeleton vector of the weighted options (weight by width_max and width)</span>

<span class="sd">    Pseudocode:</span>
<span class="sd">    For each compartment:</span>
<span class="sd">    a. Find the max width</span>
<span class="sd">    b. keep that dict for the max width one (add max to the labels)</span>
<span class="sd">    c. For vectors (soma and skeleton), do a weighted average with all widths and add to dict</span>
<span class="sd">    d. add compartment prefixs to dictionary and add to list</span>

<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">total_comp_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">compartments</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;-- Working on consolidating </span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2"> --&quot;</span><span class="p">)</span>
        <span class="n">curr_dicts</span> <span class="o">=</span> <span class="n">comp_dict</span><span class="p">[</span><span class="n">comp</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_dicts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">widths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;width&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_dicts</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;widths = </span><span class="si">{</span><span class="n">widths</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">width_max_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">widths</span><span class="p">)</span>
        <span class="n">max_dict</span> <span class="o">=</span> <span class="n">curr_dicts</span><span class="p">[</span><span class="n">width_max_idx</span><span class="p">]</span>

        <span class="c1">#do weighted average of all the vectors</span>
        <span class="n">soma_vectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">k</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;soma_vector_</span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">_nm&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span><span class="s2">&quot;y&quot;</span><span class="p">,</span><span class="s2">&quot;z&quot;</span><span class="p">]])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_dicts</span><span class="p">])</span>
        <span class="n">skeletal_vectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">k</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;skeleton_vector_</span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">_nm&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span><span class="s2">&quot;y&quot;</span><span class="p">,</span><span class="s2">&quot;z&quot;</span><span class="p">]])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_dicts</span><span class="p">])</span>

        <span class="n">soma_vector_weighted</span><span class="o">=</span><span class="n">nu</span><span class="o">.</span><span class="n">weighted_average_along_axis</span><span class="p">(</span>
            <span class="n">soma_vectors</span><span class="p">,</span><span class="n">weights</span><span class="o">=</span><span class="n">widths</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
        <span class="p">)</span>

        <span class="n">skeleton_vector_weighted</span><span class="o">=</span><span class="n">nu</span><span class="o">.</span><span class="n">weighted_average_along_axis</span><span class="p">(</span>
            <span class="n">skeletal_vectors</span><span class="p">,</span><span class="n">weights</span><span class="o">=</span><span class="n">widths</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
        <span class="p">)</span>

        <span class="n">final_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">max_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
            <span class="n">n_limbs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_dicts</span><span class="p">),</span>
            <span class="n">soma_vector_weighted_x_nm</span> <span class="o">=</span> <span class="n">soma_vector_weighted</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">soma_vector_weighted_y_nm</span> <span class="o">=</span> <span class="n">soma_vector_weighted</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">soma_vector_weighted_z_nm</span> <span class="o">=</span> <span class="n">soma_vector_weighted</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>

            <span class="n">skeleton_vector_weighted_x_nm</span> <span class="o">=</span> <span class="n">skeleton_vector_weighted</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">skeleton_vector_weighted_y_nm</span> <span class="o">=</span> <span class="n">skeleton_vector_weighted</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">skeleton_vector_weighted_z_nm</span> <span class="o">=</span> <span class="n">skeleton_vector_weighted</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">comp</span> <span class="o">==</span> <span class="s2">&quot;apicalshaft&quot;</span><span class="p">:</span>
            <span class="n">comp</span> <span class="o">=</span> <span class="s2">&quot;apical&quot;</span>
        <span class="c1">#append the compartment name</span>
        <span class="n">final_dict</span> <span class="o">=</span> <span class="p">{</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">final_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">total_comp_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">final_dict</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">total_comp_dict</span></div>

<div class="viewcode-block" id="G_no_soma"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.G_no_soma">[docs]</a><span class="k">def</span> <span class="nf">G_no_soma</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">soma_node_name</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">soma_node_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">soma_node_name</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">soma_node_name_global</span>
    <span class="k">return</span> <span class="n">xu</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">(</span><span class="n">G</span><span class="p">,[</span><span class="n">soma_node_name</span><span class="p">])</span></div>

<div class="viewcode-block" id="all_node_graphs"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.all_node_graphs">[docs]</a><span class="k">def</span> <span class="nf">all_node_graphs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">G_no_soma</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>             
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;components = </span><span class="si">{</span><span class="n">components</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">return_graphs</span> <span class="o">=</span> <span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">([</span><span class="n">n</span><span class="p">])</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                     <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()]</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of node subgraphs = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">return_graphs</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">return_graphs</span></div>

<div class="viewcode-block" id="skeleton_downstream_of_node"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.skeleton_downstream_of_node">[docs]</a><span class="k">def</span> <span class="nf">skeleton_downstream_of_node</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">node</span><span class="p">,</span>
    <span class="n">include_self</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">return_verts_edges</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,):</span>
    <span class="k">return</span> <span class="n">nxu</span><span class="o">.</span><span class="n">skeleton</span><span class="p">(</span>
        <span class="n">xu</span><span class="o">.</span><span class="n">subgraph_downstream_of_node</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">,</span><span class="n">include_self</span><span class="o">=</span><span class="n">include_self</span><span class="p">),</span>
        <span class="n">return_verts_edges</span><span class="o">=</span><span class="n">return_verts_edges</span><span class="p">,</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="all_compartment_subgraphs"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.all_compartment_subgraphs">[docs]</a><span class="k">def</span> <span class="nf">all_compartment_subgraphs</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">compartments</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_empty_graphs</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
    
    <span class="k">if</span> <span class="n">compartments</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1">#compartments = getattr(nxu,f&quot;compartments_{cell_type}&quot;)</span>
        <span class="n">compartments</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">nxu</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;compartments&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Compartments Trying = </span><span class="si">{</span><span class="n">compartments</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="n">comp_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">nxu</span><span class="o">.</span><span class="n">compartment_subgraph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">compartments</span><span class="p">}</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">return_empty_graphs</span><span class="p">:</span>
        <span class="n">comp_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">comp_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">}</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Compartments Returning = </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">comp_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">comp_dict</span></div>
        
<div class="viewcode-block" id="all_compartment_skeletons"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.all_compartment_skeletons">[docs]</a><span class="k">def</span> <span class="nf">all_compartment_skeletons</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">compartments</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">return_empty_skeletons</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get all the compartment skeletons</span>
<span class="sd">    from a graph</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">comp_subs</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">all_compartment_subgraphs</span><span class="p">(</span>
        <span class="n">G</span><span class="p">,</span>
        <span class="n">compartments</span> <span class="o">=</span> <span class="n">compartments</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
        <span class="n">return_empty_graphs</span> <span class="o">=</span> <span class="n">return_empty_skeletons</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="n">comp_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">nxu</span><span class="o">.</span><span class="n">skeleton</span><span class="p">(</span><span class="n">sub_G</span><span class="p">,</span><span class="n">include_soma</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">sub_G</span> <span class="ow">in</span> <span class="n">comp_subs</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    
    
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">new_figure</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_mesh</span><span class="p">(</span>
                <span class="n">mesh</span><span class="p">,</span>
                <span class="n">new_figure</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">show_at_end</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">flip_y</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.1</span>
            <span class="p">)</span>
            <span class="n">new_figure</span> <span class="o">=</span> <span class="kc">False</span>
            
        <span class="n">comp_dict_to_plot</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">comp_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,(</span><span class="n">k</span><span class="p">,(</span><span class="n">skeleton_nodes</span><span class="p">,</span><span class="n">skeleton_edges</span><span class="p">))</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">comp_dict_to_plot</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">color</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">compartment_colors</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp_dict_to_plot</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">show_at_end</span><span class="o">=</span><span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">show_at_end</span> <span class="o">=</span> <span class="kc">False</span>
            
            <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_skeleton</span><span class="p">(</span>
               <span class="n">skeleton_nodes</span><span class="p">,</span>
                <span class="n">skeleton_edges</span><span class="p">,</span>
                <span class="n">new_figure</span> <span class="o">=</span> <span class="n">new_figure</span><span class="p">,</span>
                <span class="n">show_at_end</span> <span class="o">=</span> <span class="n">show_at_end</span><span class="p">,</span>
                <span class="n">color</span> <span class="o">=</span> <span class="n">color</span>
            <span class="p">)</span>
            
            <span class="n">new_figure</span> <span class="o">=</span> <span class="kc">False</span>
            
    <span class="k">return</span> <span class="n">comp_dict</span></div>

<div class="viewcode-block" id="plot_all_skeleton_compartments"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.plot_all_skeleton_compartments">[docs]</a><span class="k">def</span> <span class="nf">plot_all_skeleton_compartments</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">mesh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">nxu</span><span class="o">.</span><span class="n">all_compartment_skeletons</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    
    

<div class="viewcode-block" id="skeleton_edge_df_with_edge_graph_with_compartments"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.skeleton_edge_df_with_edge_graph_with_compartments">[docs]</a><span class="k">def</span> <span class="nf">skeleton_edge_df_with_edge_graph_with_compartments</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_edge_G</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">remove_starter_branches</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get all the edge data for all compartments</span>
<span class="sd">    and to have a graph representation of those edges so can </span>
<span class="sd">    walk along:</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Reduce the vertices down to unique vertices and edges (and pass back the index)</span>
<span class="sd">    2) Turn the vertices into a graph (and each node should have a compartment)</span>
<span class="sd">    3) Trun graph into an edge graph</span>
<span class="sd">    --&gt; use the new node names to index into compartment and get the mode</span>
<span class="sd">    --&gt; use node names to index into coordinates and compute: skeletal length and midpoint</span>

<span class="sd">    store all in dataframe for the edges</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">remove_starter_branches</span><span class="p">:</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">remove_small_starter_branches</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

    <span class="n">comp_skeletons</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">all_compartment_skeletons</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,)</span>

    <span class="n">nodes_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">edges_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">comp_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">comp</span><span class="p">,(</span><span class="n">nodes</span><span class="p">,</span><span class="n">edges</span><span class="p">)</span> <span class="ow">in</span> <span class="n">comp_skeletons</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Working on </span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">nodes_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
        <span class="n">edges_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edges</span> <span class="o">+</span> <span class="n">counter</span><span class="p">)</span>
        <span class="n">comp_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)))</span>

        <span class="n">counter</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>

    <span class="n">nodes_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">nodes_list</span><span class="p">)</span>
    <span class="n">edges_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">edges_list</span><span class="p">)</span>
    <span class="n">comp_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">comp_list</span><span class="p">)</span>

    <span class="n">nodes_unique</span><span class="p">,</span><span class="n">edges_unique</span><span class="p">,</span><span class="n">node_orig_idx</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">unique_vertices_edges_from_vertices_edges</span><span class="p">(</span>
        <span class="n">nodes_list</span><span class="p">,</span>
        <span class="n">edges_list</span><span class="p">,</span>
        <span class="n">return_vertex_index</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span>

    <span class="n">comps_per_node</span> <span class="o">=</span> <span class="n">comp_list</span><span class="p">[</span><span class="n">node_orig_idx</span><span class="p">]</span>
    <span class="n">coord_per_nodes</span> <span class="o">=</span> <span class="n">nodes_list</span><span class="p">[</span><span class="n">node_orig_idx</span><span class="p">]</span>

    <span class="n">G_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">graph_from_unique_vertices_edges</span><span class="p">(</span>
        <span class="n">nodes_unique</span><span class="p">,</span>
        <span class="n">edges_unique</span>
    <span class="p">)</span>

    <span class="n">G_edge</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">edge_graph</span><span class="p">(</span><span class="n">G_node</span><span class="p">)</span>
    <span class="n">edge_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G_edge</span><span class="o">.</span><span class="n">nodes</span><span class="p">()))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>


    <span class="n">edge_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">edge_dict</span><span class="p">[</span><span class="s2">&quot;edge_coord&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord_per_nodes</span><span class="p">[</span><span class="n">edge_nodes</span><span class="p">]</span>
    <span class="n">edge_dict</span><span class="p">[</span><span class="s2">&quot;compartment&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">mode</span><span class="p">(</span><span class="n">comps_per_node</span><span class="p">[</span><span class="n">edge_nodes</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">edge_dict</span><span class="p">[</span><span class="s2">&quot;skeletal_length&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
        <span class="n">coord_per_nodes</span><span class="p">[</span><span class="n">edge_nodes</span><span class="p">][:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span>
        <span class="n">coord_per_nodes</span><span class="p">[</span><span class="n">edge_nodes</span><span class="p">][:,</span><span class="mi">0</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">edge_dict</span><span class="p">[</span><span class="s2">&quot;midpoint&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">coord_per_nodes</span><span class="p">[</span><span class="n">edge_nodes</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">edge_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">({</span><span class="n">k</span><span class="p">:</span><span class="nb">list</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">edge_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
    
    <span class="n">G_edge</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">xu</span><span class="o">.</span><span class="n">relabel_node_names</span><span class="p">(</span>
        <span class="n">G_edge</span><span class="p">,{</span><span class="nb">tuple</span><span class="p">(</span><span class="n">k</span><span class="p">):</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">edge_nodes</span><span class="p">))}</span>
    <span class="p">)</span>

    <span class="c1"># plot to make sure coordinates came out well</span>

    <span class="c1">#plot to make sure assembled correctly</span>
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_scatter</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">edge_df</span><span class="p">[</span><span class="s2">&quot;midpoint&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()),</span>
            <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="n">nxu</span><span class="o">.</span><span class="n">compartment_colors</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">edge_df</span><span class="p">[</span><span class="s2">&quot;compartment&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()],</span>
        <span class="p">)</span>
        
    <span class="k">if</span> <span class="n">return_edge_G</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">edge_df</span><span class="p">,</span><span class="n">G_edge</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">edge_df</span></div>
    
<div class="viewcode-block" id="all_compartment_conn_comp_subgraphs"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.all_compartment_conn_comp_subgraphs">[docs]</a><span class="k">def</span> <span class="nf">all_compartment_conn_comp_subgraphs</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">compartments</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_compartments</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Divide a neuron graph</span>
<span class="sd">    into the connected components of each</span>
<span class="sd">    compartment type (so 2 oblique branches</span>
<span class="sd">    should be 2 different subgraphs)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#1) Divide neuron into different compartment</span>
    <span class="n">comp_subgraphs</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">all_compartment_subgraphs</span><span class="p">(</span>
        <span class="n">G</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
        <span class="n">compartments</span><span class="o">=</span><span class="n">compartments</span><span class="p">)</span>

    <span class="c1">#2) Divide all subgraphs into connected components</span>
    <span class="n">all_subgraphs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">all_subgraphs_comps</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">comp</span><span class="p">,</span><span class="n">sub_G</span> <span class="ow">in</span> <span class="n">comp_subgraphs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">comp_Gs</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">connected_components_subgraphs</span><span class="p">(</span><span class="n">sub_G</span><span class="p">)</span>
        <span class="n">all_subgraphs</span> <span class="o">+=</span> <span class="n">comp_Gs</span>
        <span class="n">all_subgraphs_comps</span> <span class="o">+=</span> <span class="p">[</span><span class="n">comp</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_Gs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total number of subgraphs = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">all_subgraphs</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_subgraphs_comps</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">lab</span><span class="p">,</span><span class="n">count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">all_subgraphs_comps</span><span class="p">,</span><span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">l</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lab</span><span class="p">,</span><span class="n">count</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   </span><span class="si">{</span><span class="n">l</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_compartments</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">all_subgraphs</span><span class="p">,</span><span class="n">all_subgraphs_comps</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">all_subgraphs</span></div>
    
    
<div class="viewcode-block" id="all_compartment_conn_comp_subgraph_vector_stats"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.all_compartment_conn_comp_subgraph_vector_stats">[docs]</a><span class="k">def</span> <span class="nf">all_compartment_conn_comp_subgraph_vector_stats</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">small_starter_branch_skeletal_length_min</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
    <span class="n">filter_starter_branches</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">upstream_dist_max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">debug_idx</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">return_subgraphs</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">include_scholl_coordinates</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">include_scholl_coordinates_adjusted</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">return_df</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To divide a neuron into individual connected components of the</span>
<span class="sd">    interested compartments. and then to calculate the following stats about them</span>

<span class="sd">    1) soma vector</span>
<span class="sd">    2) skeleton vector</span>
<span class="sd">    3) width</span>
<span class="sd">    4) y above the soma</span>
<span class="sd">    5) skeletal length</span>
<span class="sd">    6) The intersection points at different </span>
<span class="sd">    lengths from the soma (on the xz plane)</span>
<span class="sd">    - predefine a stepsize and go as far as need be</span>


<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Divide neuron into different compartment</span>
<span class="sd">    subgraphs</span>
<span class="sd">    2) Divide all subgraphs into connected components</span>
<span class="sd">    (put into one list)</span>
<span class="sd">    3) For each graph in the list compute:</span>
<span class="sd">    a. starting width</span>
<span class="sd">    b. starting y above the soma</span>
<span class="sd">    c. soma angle</span>
<span class="sd">    d. skeletal angle</span>
<span class="sd">    e. skeletal width</span>
<span class="sd">    f. intersection points of skeleton </span>
<span class="sd">    g. starting endpoint</span>
<span class="sd">    (for as far as can go or max distance)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">upstream_dist_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">upstream_dist_max</span> <span class="o">=</span> <span class="n">default_upstream_dist_max</span>

    <span class="k">if</span> <span class="n">debug_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">debug_idx</span> <span class="o">=</span> <span class="p">[]</span>


    <span class="c1">#0) Filter the starter branches</span>
    <span class="k">if</span> <span class="n">filter_starter_branches</span><span class="p">:</span>
        <span class="n">G_filt</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">remove_small_starter_branches</span><span class="p">(</span>
            <span class="n">G</span><span class="p">,</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
            <span class="n">skeletal_length_min</span><span class="o">=</span><span class="n">small_starter_branch_skeletal_length_min</span><span class="p">,</span>
            <span class="n">maintain_skeleton_connectivity</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="p">)</span>

    <span class="c1">#1) Getting the soma coordinate (for later computation)</span>
    <span class="n">soma_coordinate</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">soma_center</span><span class="p">(</span><span class="n">G_filt</span><span class="p">)</span>

    <span class="n">comp_subgraphs</span><span class="p">,</span><span class="n">comps</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">all_compartment_conn_comp_subgraphs</span><span class="p">(</span>
        <span class="n">G_filt</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
    <span class="p">)</span>

    <span class="n">all_dicts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_subgraphs</span><span class="p">)):</span>
        <span class="n">subG</span><span class="p">,</span><span class="n">comp</span> <span class="o">=</span> <span class="n">comp_subgraphs</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span><span class="n">comps</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--- Working on subgraph </span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">: comp = </span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">, n_nodes = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">subG</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>

        <span class="n">curr_dict</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">vector_stats_from_G</span><span class="p">(</span>
            <span class="n">subG</span><span class="p">,</span>
            <span class="n">soma_coordinate</span><span class="o">=</span><span class="n">soma_coordinate</span><span class="p">,</span>
            <span class="n">include_scholl_coordinates</span> <span class="o">=</span> <span class="n">include_scholl_coordinates</span><span class="p">,</span>
            <span class="n">include_scholl_coordinates_adjusted</span> <span class="o">=</span> <span class="n">include_scholl_coordinates_adjusted</span><span class="p">,</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="p">)</span>

        <span class="n">curr_dict</span><span class="p">[</span><span class="s2">&quot;compartment&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">comp</span>
        <span class="n">curr_dict</span><span class="p">[</span><span class="s2">&quot;subgraph_idx&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
        
        <span class="k">if</span> <span class="n">return_subgraphs</span><span class="p">:</span>
            <span class="n">curr_dict</span><span class="p">[</span><span class="s2">&quot;G&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">subG</span>


        <span class="k">if</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">debug_idx</span><span class="p">:</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
                <span class="n">mesh</span><span class="p">,</span>
                <span class="n">scatters</span> <span class="o">=</span> <span class="p">[</span>
                   <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">curr_dict</span><span class="p">[</span><span class="s2">&quot;node&quot;</span><span class="p">]][</span><span class="s2">&quot;skeleton_data&quot;</span><span class="p">],</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">curr_dict</span><span class="p">[</span><span class="s2">&quot;scholl_coords&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
                <span class="p">],</span>
            <span class="p">)</span>

        <span class="n">all_dicts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_dict</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">return_df</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_records</span><span class="p">(</span><span class="n">all_dicts</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">all_dicts</span></div>

<div class="viewcode-block" id="skeleton_bbox"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.skeleton_bbox">[docs]</a><span class="k">def</span> <span class="nf">skeleton_bbox</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">return_dict</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">suffix</span> <span class="o">=</span> <span class="s2">&quot;_nm&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find the skeleton&#39;s bounding box</span>

<span class="sd">    1) Generate the skeleton</span>
<span class="sd">    2) Send the vertices to the bounding box</span>
<span class="sd">    3) Return dict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">verts</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">skeleton</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">return_verts_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">bbox</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">bouning_box_corners</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span><span class="n">return_dict</span> <span class="o">=</span> <span class="n">return_dict</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_dict</span><span class="p">:</span>
        <span class="n">bbox</span> <span class="o">=</span> <span class="p">{</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}{</span><span class="n">suffix</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">bbox</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;bbox = </span><span class="si">{</span><span class="n">bbox</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">bbox</span></div>

<div class="viewcode-block" id="internal_branching_coordinates"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.internal_branching_coordinates">[docs]</a><span class="k">def</span> <span class="nf">internal_branching_coordinates</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Calculate the internal branch</span>
<span class="sd">    coordinates</span>

<span class="sd">    Application: Can calculate the closest and farthest away </span>
<span class="sd">    internal branch points</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    2) Find all nodes not the leaf nodes and record their endpoints</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">non_leaf</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">non_leaf_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="n">internal_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;endpoint_downstream&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">non_leaf</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">internal_coordinates</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">internal_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">internal_coordinates</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;internal_coordinates = </span><span class="si">{</span><span class="n">internal_coordinates</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">internal_coordinates</span></div>

<div class="viewcode-block" id="n_internal_branching_coordinates"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.n_internal_branching_coordinates">[docs]</a><span class="k">def</span> <span class="nf">n_internal_branching_coordinates</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">nxu</span><span class="o">.</span><span class="n">internal_branching_coordinates</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">))</span></div>

<div class="viewcode-block" id="internal_branching_coordinates_max_min"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.internal_branching_coordinates_max_min">[docs]</a><span class="k">def</span> <span class="nf">internal_branching_coordinates_max_min</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">default_value</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_dict</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_distance</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">suffix</span> <span class="o">=</span> <span class="s2">&quot;_nm&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Find the farthest and closest</span>
<span class="sd">    internal branching point</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get the most upstream endpoint</span>
<span class="sd">    2) Get all the internal branch points</span>
<span class="sd">    3) Calculate the distance of all the internal branch points</span>
<span class="sd">    4) Pick the largest and smallest distance</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    nxu.internal_branching_coordinates_max_min(</span>
<span class="sd">        subG,</span>
<span class="sd">        plot = True,</span>
<span class="sd">        return_dict = True,</span>
<span class="sd">        verbose = True,</span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">coord</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">most_upstream_coordinate</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="n">branch_coords</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">internal_branching_coordinates</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">branch_coords</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">branch_coords</span><span class="o">-</span> <span class="n">coord</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">max_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">dists</span><span class="p">)</span>
        <span class="n">min_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dists</span><span class="p">)</span>
        
        <span class="n">max_dist</span> <span class="o">=</span> <span class="n">dists</span><span class="p">[</span><span class="n">max_idx</span><span class="p">]</span>
        <span class="n">min_dist</span> <span class="o">=</span> <span class="n">dists</span><span class="p">[</span><span class="n">min_idx</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Max branch coord dist = </span><span class="si">{</span><span class="n">max_dist</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Min branch coord dist = </span><span class="si">{</span><span class="n">min_dist</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">max_branch_coord</span> <span class="o">=</span> <span class="n">branch_coords</span><span class="p">[</span><span class="n">max_idx</span><span class="p">]</span>
        <span class="n">min_branch_coord</span> <span class="o">=</span> <span class="n">branch_coords</span><span class="p">[</span><span class="n">min_idx</span><span class="p">]</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">max_branch_coord</span><span class="o">=</span><span class="n">max_branch_coord</span><span class="o">=</span><span class="n">max_dist</span><span class="o">=</span><span class="n">min_dist</span><span class="o">=</span> <span class="n">default_value</span>
        
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;max_branch_coord = </span><span class="si">{</span><span class="n">max_branch_coord</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;min_branch_coord = </span><span class="si">{</span><span class="n">min_branch_coord</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_skeleton</span><span class="p">(</span>
            <span class="o">*</span><span class="n">nxu</span><span class="o">.</span><span class="n">skeleton</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">return_verts_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="n">show_at_end</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="p">)</span>
        <span class="n">max_branch_color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span>
        <span class="n">min_branch_color</span> <span class="o">=</span> <span class="s2">&quot;blue&quot;</span>
        <span class="n">start_coordinate</span> <span class="o">=</span> <span class="s2">&quot;black&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;max_branch_color = </span><span class="si">{</span><span class="n">max_branch_color</span><span class="si">}</span><span class="s2">, min_branch_color = </span><span class="si">{</span><span class="n">min_branch_color</span><span class="si">}</span><span class="s2">, start_coordinate = </span><span class="si">{</span><span class="n">start_coordinate</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_multi_scatters</span><span class="p">(</span>
            <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">max_branch_coord</span><span class="p">,</span><span class="n">min_branch_coord</span><span class="p">,</span><span class="n">coord</span><span class="p">],</span>
            <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="n">max_branch_color</span><span class="p">,</span><span class="n">min_branch_color</span><span class="p">,</span><span class="n">start_coordinate</span><span class="p">],</span>
            <span class="n">new_figure</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">return_dict</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_distance</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="sa">f</span><span class="s2">&quot;internal_branch_coordinate_max_dist</span><span class="si">{</span><span class="n">suffix</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span><span class="n">max_dist</span><span class="p">,</span>
                <span class="sa">f</span><span class="s2">&quot;internal_branch_coordinate_min_dist</span><span class="si">{</span><span class="n">suffix</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span><span class="n">min_dist</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">max_branch_coord</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">max_branch_coord</span> <span class="o">=</span> <span class="n">min_branch_coord</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="sa">f</span><span class="s2">&quot;internal_branch_coordinate_max_x</span><span class="si">{</span><span class="n">suffix</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span><span class="n">max_branch_coord</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="sa">f</span><span class="s2">&quot;internal_branch_coordinate_max_y</span><span class="si">{</span><span class="n">suffix</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span><span class="n">max_branch_coord</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="sa">f</span><span class="s2">&quot;internal_branch_coordinate_max_z</span><span class="si">{</span><span class="n">suffix</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span><span class="n">max_branch_coord</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>

                <span class="sa">f</span><span class="s2">&quot;internal_branch_coordinate_min_x</span><span class="si">{</span><span class="n">suffix</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span><span class="n">min_branch_coord</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="sa">f</span><span class="s2">&quot;internal_branch_coordinate_min_y</span><span class="si">{</span><span class="n">suffix</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span><span class="n">min_branch_coord</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="sa">f</span><span class="s2">&quot;internal_branch_coordinate_min_z</span><span class="si">{</span><span class="n">suffix</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span><span class="n">min_branch_coord</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
            <span class="p">}</span>
       
    <span class="k">if</span> <span class="n">return_distance</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">max_dist</span><span class="p">,</span><span class="n">min_dist</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">max_branch_coord</span><span class="p">,</span><span class="n">min_branch_coord</span></div>

<div class="viewcode-block" id="internal_branching_stats"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.internal_branching_stats">[docs]</a><span class="k">def</span> <span class="nf">internal_branching_stats</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">include_max_min_coordinates</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">include_max_min_dist</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">curr_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">n_internal_branching</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">n_internal_branching_coordinates</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">include_max_min_coordinates</span><span class="p">:</span>
        <span class="n">max_min_branch_dict</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">internal_branching_coordinates_max_min</span><span class="p">(</span>
            <span class="n">G</span><span class="p">,</span>
            <span class="n">return_distance</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">return_dict</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        
        <span class="n">curr_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">max_min_branch_dict</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">include_max_min_dist</span><span class="p">:</span>
        <span class="n">max_min_branch_dict</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">internal_branching_coordinates_max_min</span><span class="p">(</span>
            <span class="n">G</span><span class="p">,</span>
            <span class="n">return_distance</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">return_dict</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        
        <span class="n">curr_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">max_min_branch_dict</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">curr_dict</span></div>

<span class="n">default_small_endnodes_skeltal_length_min</span> <span class="o">=</span> <span class="mi">10_000</span>
<div class="viewcode-block" id="small_endnode_branches"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.small_endnode_branches">[docs]</a><span class="k">def</span> <span class="nf">small_endnode_branches</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">dendrite_only</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">skeletal_length_min</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">exclude_soma_connected_nodes</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To detect any end nodes</span>
<span class="sd">    that are below a certain skeletal length</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Find all of the leaf nodes</span>
<span class="sd">    2) Find the skeletal length of all the leaf nodes</span>
<span class="sd">    3) Identify any that are subthreshold</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dendrite_only</span><span class="p">:</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">dendrite_subgraph</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">skeletal_length_min</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">skeletal_length_min</span> <span class="o">=</span> <span class="n">default_small_endnodes_skeltal_length_min</span>
    
    <span class="k">if</span> <span class="n">nxu</span><span class="o">.</span><span class="n">soma_only_graph</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[]</span>
    
    <span class="n">leaf_nodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">leaf_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">exclude_soma_connected_nodes</span><span class="p">:</span>
        <span class="n">leaf_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">leaf_nodes</span><span class="p">,</span><span class="n">nxu</span><span class="o">.</span><span class="n">soma_connected_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Leaf nodes (after soma connected excluded): </span><span class="si">{</span><span class="n">leaf_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="n">leaf_nodes_sub_thresh</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">leaf_nodes</span> <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;skeletal_length&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">skeletal_length_min</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Leaf nodes (after skeletal length min </span><span class="si">{</span><span class="n">skeletal_length_min</span><span class="si">}</span><span class="s2">) = </span><span class="si">{</span><span class="n">leaf_nodes_sub_thresh</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">leaf_nodes_sub_thresh</span></div>

<div class="viewcode-block" id="remove_small_endnode_branches"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.remove_small_endnode_branches">[docs]</a><span class="k">def</span> <span class="nf">remove_small_endnode_branches</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">skeletal_length_min</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">inplace</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">loop_until_fail</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To iteratively remove small endnode branches</span>
<span class="sd">    from a graph</span>

<span class="sd">    Application: When split into separate path graphs,</span>
<span class="sd">    don&#39;t want more paths created just because have small</span>
<span class="sd">    endnodes on them</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">sm_end_branches</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">small_endnode_branches</span><span class="p">(</span>
            <span class="n">G</span><span class="p">,</span>
            <span class="c1">#skeletal_length_min = 20_000,</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Soma End Node Branches = </span><span class="si">{</span><span class="n">sm_end_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">G</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">(</span><span class="n">sm_end_branches</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">loop_until_fail</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">sm_end_branches</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">continue</span>

    <span class="k">return</span> <span class="n">G</span></div>

<div class="viewcode-block" id="n_scholl_dict_from_scholl_dict"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.n_scholl_dict_from_scholl_dict">[docs]</a><span class="k">def</span> <span class="nf">n_scholl_dict_from_scholl_dict</span><span class="p">(</span>
    <span class="n">scholl_dict</span><span class="p">,</span>
    <span class="n">return_named_dict</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prefix</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="p">):</span>
    
    <span class="n">n_scholl_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">scholl_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">if</span> <span class="n">return_named_dict</span><span class="p">:</span>
        <span class="n">n_scholl_dict</span> <span class="o">=</span> <span class="p">{</span><span class="sa">f</span><span class="s2">&quot;n_scholl</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">n_scholl_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    
    <span class="k">return</span> <span class="n">n_scholl_dict</span></div>

<div class="viewcode-block" id="subgraph_df_and_endnodes_df"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.subgraph_df_and_endnodes_df">[docs]</a><span class="k">def</span> <span class="nf">subgraph_df_and_endnodes_df</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">remove_small_endnodes</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">include_scholl_coordinates</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">include_scholl_coordinates_adjusted</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">include_n_scholl</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">endnode_name</span> <span class="o">=</span> <span class="s2">&quot;leaf_node&quot;</span><span class="p">,</span>
    <span class="n">ignore_axon</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To compute both the subgraph vector dataframe and the </span>
<span class="sd">    offshoot vector dataframes</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Calculate the subgraph df. WILL RETURN</span>
<span class="sd">    2) For each compartment subgraph (each entry in the subgraph df):</span>
<span class="sd">        For All end-nodes</span>
<span class="sd">        a. Run the stats</span>
<span class="sd">        b. Add a leaf node column</span>
<span class="sd">        c. Add on the endpoint coordinate</span>
<span class="sd">        d. Attributes to add on: </span>
<span class="sd">        - subgraph_idx</span>
<span class="sd">        - endnode_idx</span>
<span class="sd">    3) Compile into endnode dataframe</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">remove_small_endnodes</span><span class="p">:</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">remove_small_endnode_branches</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span> <span class="kc">False</span><span class="p">)</span>

    <span class="n">soma_coordinate</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">soma_center</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

    <span class="c1">#1) Calculate the subgraph df. WILL RETURN</span>
    <span class="n">subgraph_df</span><span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">all_compartment_conn_comp_subgraph_vector_stats</span><span class="p">(</span>
        <span class="n">G</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_subgraphs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">return_df</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span>

    <span class="n">endnode_dicts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">subgraph_dict</span> <span class="ow">in</span> <span class="n">pu</span><span class="o">.</span><span class="n">df_to_dicts</span><span class="p">(</span><span class="n">subgraph_df</span><span class="p">):</span>
        <span class="n">subgraph_idx</span> <span class="o">=</span> <span class="n">subgraph_dict</span><span class="p">[</span><span class="s2">&quot;subgraph_idx&quot;</span><span class="p">]</span>
        <span class="n">leaf_nodes</span> <span class="o">=</span> <span class="n">subgraph_dict</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">endnode_name</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">subgraph_dict</span><span class="p">[</span><span class="s2">&quot;compartment&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;axon&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">ignore_axon</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">continue</span>
            
        <span class="n">subG</span> <span class="o">=</span> <span class="n">subgraph_dict</span><span class="p">[</span><span class="s2">&quot;G&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    -- Working on subgraph </span><span class="si">{</span><span class="n">subgraph_idx</span><span class="si">}</span><span class="s2"> --&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">endnode</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">leaf_nodes</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;       -- working on endnode </span><span class="si">{</span><span class="n">leaf_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">endG</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">shortest_path_graph_from_most_upstream</span><span class="p">(</span>
                <span class="n">subG</span><span class="p">,</span>
                <span class="n">endnode</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1">#a. Run the stats</span>
            <span class="n">curr_dict</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">vector_stats_from_G</span><span class="p">(</span>
                <span class="n">endG</span><span class="p">,</span>
                <span class="n">soma_coordinate</span><span class="o">=</span><span class="n">soma_coordinate</span><span class="p">,</span>
                <span class="n">include_scholl_coordinates</span> <span class="o">=</span> <span class="n">include_scholl_coordinates</span><span class="p">,</span>
                <span class="n">include_scholl_coordinates_adjusted</span> <span class="o">=</span> <span class="n">include_scholl_coordinates_adjusted</span><span class="p">,</span>
                <span class="n">include_n_scholl</span> <span class="o">=</span> <span class="n">include_n_scholl</span><span class="p">,</span>
                <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1">#b. Add a leaf node column</span>
            <span class="n">curr_dict</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">endnode_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">endnode</span>

            <span class="c1">#c. Add on the endpoint coordinate</span>
            <span class="n">endnode_coordinate</span> <span class="o">=</span> <span class="n">endG</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">endnode</span><span class="p">][</span><span class="s2">&quot;endpoint_downstream&quot;</span><span class="p">]</span>
            <span class="n">curr_dict</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">endnode_name</span><span class="si">}</span><span class="s2">_coordinate_x_nm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">endnode_coordinate</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">curr_dict</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">endnode_name</span><span class="si">}</span><span class="s2">_coordinate_y_nm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">endnode_coordinate</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">curr_dict</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">endnode_name</span><span class="si">}</span><span class="s2">_coordinate_z_nm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">endnode_coordinate</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">curr_dict</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">endnode_name</span><span class="si">}</span><span class="s2">_dist&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
                <span class="n">soma_coordinate</span> <span class="o">-</span> <span class="n">endnode_coordinate</span><span class="p">)</span>

            <span class="c1">#d. Attributes to add on: subgraph_idx, endnode_idx</span>
            <span class="n">curr_dict</span><span class="p">[</span><span class="s2">&quot;subgraph_idx&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">subgraph_idx</span>
            <span class="n">curr_dict</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">endnode_name</span><span class="si">}</span><span class="s2">_idx&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>

            <span class="n">endnode_dicts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_dict</span><span class="p">)</span>

    <span class="n">endnode_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_records</span><span class="p">(</span><span class="n">endnode_dicts</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of subgraph entries = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">subgraph_df</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of endnode entries = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">endnode_df</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">subgraph_df</span><span class="p">,</span><span class="n">endnode_df</span></div>

<div class="viewcode-block" id="shortest_path_from_most_upstream"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.shortest_path_from_most_upstream">[docs]</a><span class="k">def</span> <span class="nf">shortest_path_from_most_upstream</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">node</span><span class="p">,</span>
    <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;S0&quot;</span><span class="p">,),</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ex: </span>
<span class="sd">    nxu.shortest_path_from_most_upstream(</span>
<span class="sd">        G,</span>
<span class="sd">        node=&quot;L0_1&quot;,</span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">return</span> <span class="n">xu</span><span class="o">.</span><span class="n">shortest_path_from_most_upstream</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span>
    <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="n">nodes_to_exclude</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="node_endpoint"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.node_endpoint">[docs]</a><span class="k">def</span> <span class="nf">node_endpoint</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">):</span>
    <span class="n">node</span><span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">array_like</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span>
        <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;endpoint_downstream&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">node</span><span class="p">])</span></div>


<div class="viewcode-block" id="coordinates_from_coordinate_type"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.coordinates_from_coordinate_type">[docs]</a><span class="k">def</span> <span class="nf">coordinates_from_coordinate_type</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">node</span><span class="p">,</span>
    <span class="n">coordinate_type</span><span class="p">,</span>
    <span class="p">):</span>
    <span class="n">node_dict</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">coordinate_type</span> <span class="o">==</span> <span class="s2">&quot;skeleton&quot;</span><span class="p">:</span>
        <span class="n">coordinate_type</span> <span class="o">=</span> <span class="s2">&quot;skeleton_data&quot;</span>
        
    <span class="k">if</span> <span class="n">coordinate_type</span> <span class="o">==</span> <span class="s2">&quot;endpoints&quot;</span><span class="p">:</span>
        <span class="n">coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">node_dict</span><span class="p">[</span><span class="s2">&quot;endpoint_upstream&quot;</span><span class="p">],</span>
                                 <span class="n">node_dict</span><span class="p">[</span><span class="s2">&quot;endpoint_downstream&quot;</span><span class="p">],])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node_dict</span><span class="p">[</span><span class="n">coordinate_type</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">coordinates</span></div>
<div class="viewcode-block" id="coordinate_array_with_node_map_from_G"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.coordinate_array_with_node_map_from_G">[docs]</a><span class="k">def</span> <span class="nf">coordinate_array_with_node_map_from_G</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">coordinate_type</span> <span class="o">=</span> <span class="s2">&quot;skeleton&quot;</span><span class="p">,</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">suppress_errors</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: to get two parallel arrays</span>
<span class="sd">    of coordinates pulled from a node somhow</span>
<span class="sd">    (skeletons points, midpoints, endpoints...)</span>
<span class="sd">    and the node name</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) For each node in limb branch:</span>
<span class="sd">    a. extract the coordinates</span>
<span class="sd">    b. Create an array of the same lenght with name of node</span>

<span class="sd">    Possible coordinate types: </span>
<span class="sd">    1) skeleton_data/skeleton</span>
<span class="sd">    2) endpoints, endpoint_upstream, endpoint_downstream</span>
<span class="sd">    3) mesh_center</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nodes</span> <span class="o">=</span>  <span class="n">nxu</span><span class="o">.</span><span class="n">limb_branch_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

    <span class="n">coordinates_array</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">node_array</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
        
        <span class="k">try</span><span class="p">:</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="n">coordinates_from_coordinate_type</span><span class="p">(</span>
                <span class="n">G</span><span class="p">,</span>
                <span class="n">node</span><span class="p">,</span>
                <span class="n">coordinate_type</span><span class="o">=</span><span class="n">coordinate_type</span><span class="p">,</span>
            <span class="p">)</span>
            
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">suppress_errors</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

        <span class="n">coordinates_array</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>
        <span class="n">node_array</span> <span class="o">+=</span> <span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coordinates_array</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">coordinates_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">coordinates_array</span><span class="p">)</span>

    <span class="n">node_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node_array</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of coordinates = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">coordinates_array</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">coordinates_array</span><span class="p">,</span><span class="n">node_array</span></div>

<div class="viewcode-block" id="closest_node_to_coordinates"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.closest_node_to_coordinates">[docs]</a><span class="k">def</span> <span class="nf">closest_node_to_coordinates</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">coordinates</span><span class="p">,</span>
    <span class="n">node_coordinate_type</span> <span class="o">=</span> <span class="s2">&quot;skeleton&quot;</span><span class="p">,</span>
    <span class="n">closest_idx_algorithm</span> <span class="o">=</span> <span class="s2">&quot;linalg&quot;</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">suppress_errors</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: map a coordinate(s) to the closest</span>
<span class="sd">    branch (using branches&#39; endpoints, </span>
<span class="sd">    upstream endpoints or all skeleton data, midpoint, etc..)</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get a mapping of all of the coordinates to </span>
<span class="sd">    the node name</span>
<span class="sd">    2) Do a kdtree mapping of coordinates to </span>
<span class="sd">    list of coordinates (or iteratively do the linalg.norm)</span>
<span class="sd">    to find the closest idx</span>
<span class="sd">    3) Map closest idx to the label</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">graph_coords</span><span class="p">,</span><span class="n">graph_labels</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">coordinate_array_with_node_map_from_G</span><span class="p">(</span>
        <span class="n">G</span><span class="p">,</span>
        <span class="n">suppress_errors</span><span class="o">=</span><span class="n">suppress_errors</span><span class="p">,</span>
        <span class="n">coordinate_type</span> <span class="o">=</span> <span class="n">node_coordinate_type</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">idx</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">closest_idx_for_each_coordinate</span><span class="p">(</span>
        <span class="n">array</span><span class="o">=</span><span class="n">coordinates</span><span class="p">,</span>
        <span class="n">array_for_idx</span><span class="o">=</span><span class="n">graph_coords</span><span class="p">,</span>
        <span class="n">closest_idx_algorithm</span> <span class="o">=</span> <span class="n">closest_idx_algorithm</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">closest_branch</span> <span class="o">=</span> <span class="n">graph_labels</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;closest_branch = </span><span class="si">{</span><span class="n">closest_branch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">closest_branch</span></div>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">def cluster_and_downstream_filter_coordinates_old(</span>
<span class="sd">    G,</span>
<span class="sd">    coordinates,</span>
<span class="sd">    radius = 5000,</span>
<span class="sd">    mapping_node_coordinate_type = &quot;skeleton&quot;,</span>
<span class="sd">    filter_away_downstream_nodes = True,</span>
<span class="sd">    return_coordinates = True,</span>
<span class="sd">    output_coordinates_type = &quot;endpoint_upstream&quot;,</span>
<span class="sd">    verbose = False,</span>
<span class="sd">    </span>
<span class="sd">    ):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    Purpose: Given a set of edit coordinates want to filter them</span>
<span class="sd">    to non-redundant coordinates with the option of filtering</span>
<span class="sd">    away any coordinates that are downstream of others </span>
<span class="sd">    (can return nodes or coordinates)</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Filter the coordinates with a radius thresholding</span>
<span class="sd">    -- how to keep only those most upstream</span>
<span class="sd">    2) Map the filtered coordinates to the closest branches</span>
<span class="sd">    3) (Optional) Filter away any downstream branches</span>
<span class="sd">    4) Return the branches are convert them to coordinates</span>
<span class="sd">    &quot;&quot;&quot;</span>


<span class="sd">    #1) Filter the coordinates with a radius thresholding</span>
<span class="sd">    mean_coordinates = nu.mean_coordinates_from_radius_threshold_clustering(</span>
<span class="sd">            coordinates,</span>
<span class="sd">            radius = radius,</span>
<span class="sd">    )</span>
<span class="sd">    </span>
<span class="sd">    if verbose:</span>
<span class="sd">        print(f&quot;# of filtered coordinates = {len(mean_coordinates)} (vs {(len(coordinates))} original)&quot;)</span>
<span class="sd">    </span>
<span class="sd">    #2) Map the filtered coordinates to the closest branches</span>
<span class="sd">    nodes = nxu.closest_node_to_coordinates(</span>
<span class="sd">        G,</span>
<span class="sd">        mean_coordinates,</span>
<span class="sd">        node_coordinate_type = mapping_node_coordinate_type,</span>
<span class="sd">        suppress_errors=suppress_errors</span>
<span class="sd">    )</span>

<span class="sd">    if verbose:</span>
<span class="sd">        print(f&quot;Matching nodes = {nodes}&quot;)</span>

<span class="sd">    #3) (Optional) Filter away any downstream branches</span>
<span class="sd">    if filter_away_downstream_nodes:</span>
<span class="sd">        nodes = xu.filter_away_downstream_nodes(G,nodes)</span>
<span class="sd">        if verbose:</span>
<span class="sd">            print(f&quot;Nodes after filtering away downstream = {nodes}&quot;)</span>

<span class="sd">    #4) Return the branches are convert them to coordinates</span>
<span class="sd">    if return_coordinates:</span>
<span class="sd">        return np.vstack([</span>
<span class="sd">            nxu.coordinates_from_coordinate_type(G,n,coordinate_type=output_coordinates_type)</span>
<span class="sd">            for n in nodes</span>
<span class="sd">        ])</span>
<span class="sd">    else:</span>
<span class="sd">        return nodes&#39;&#39;&#39;</span>
    
<div class="viewcode-block" id="cluster_and_downstream_filter_coordinates"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.cluster_and_downstream_filter_coordinates">[docs]</a><span class="k">def</span> <span class="nf">cluster_and_downstream_filter_coordinates</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">coordinates</span><span class="p">,</span>
    <span class="n">radius</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span>
    <span class="n">mapping_node_coordinate_type</span> <span class="o">=</span> <span class="s2">&quot;skeleton&quot;</span><span class="p">,</span>
    <span class="n">filter_away_downstream_nodes</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="c1">#return_coordinates = True,</span>
    <span class="c1">#output_coordinates_type = &quot;endpoint_upstream&quot;,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_downstream_skeletal_length</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">suppress_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Given a set of edit coordinates want to filter them</span>
<span class="sd">    to non-redundant coordinates with the option of filtering</span>
<span class="sd">    away any coordinates that are downstream of others </span>
<span class="sd">    (can return nodes or coordinates)</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Filter the coordinates with a radius thresholding</span>
<span class="sd">    -- how to keep only those most upstream</span>
<span class="sd">    2) Map the filtered coordinates to the closest branches</span>
<span class="sd">    3) (Optional) Filter away any downstream branches</span>
<span class="sd">    4) Return the branches are convert them to coordinates</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="c1">#2) Map the filtered coordinates to the closest branches</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">closest_node_to_coordinates</span><span class="p">(</span>
        <span class="n">G</span><span class="p">,</span>
        <span class="n">coordinates</span><span class="p">,</span>
        <span class="n">node_coordinate_type</span> <span class="o">=</span> <span class="n">mapping_node_coordinate_type</span><span class="p">,</span>
        <span class="n">suppress_errors</span><span class="o">=</span><span class="n">suppress_errors</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Matching nodes = </span><span class="si">{</span><span class="n">nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1">#3) (Optional) Filter away any downstream branches</span>
    <span class="k">if</span> <span class="n">filter_away_downstream_nodes</span><span class="p">:</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">filter_away_downstream_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">nodes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Nodes after filtering away downstream = </span><span class="si">{</span><span class="n">nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
    <span class="k">if</span> <span class="n">return_downstream_skeletal_length</span><span class="p">:</span>
        <span class="n">downstream_skeletal_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">nxst</span><span class="o">.</span><span class="n">skeletal_length_downstream</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">include_self</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
             <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">]</span>
        <span class="p">)</span>
    
    <span class="c1"># --- want to gather length information before filtering ----</span>
    <span class="n">coordinates_upstream</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span>
            <span class="n">nxu</span><span class="o">.</span><span class="n">coordinates_from_coordinate_type</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">coordinate_type</span><span class="o">=</span><span class="s2">&quot;endpoint_upstream&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span>
    <span class="p">])</span>
        
    <span class="c1">#1) Filter the coordinates with a radius thresholding</span>
    <span class="n">mean_coordinates</span><span class="p">,</span><span class="n">conn_comp</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">mean_coordinates_from_radius_threshold_clustering</span><span class="p">(</span>
            <span class="n">coordinates_upstream</span><span class="p">,</span>
            <span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span><span class="p">,</span>
            <span class="n">return_clustering_idx</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_downstream_skeletal_length</span><span class="p">:</span>
        <span class="n">downstream_skeletal_lengths</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">downstream_skeletal_lengths</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                                      <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">conn_comp</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of filtered coordinates = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">mean_coordinates</span><span class="p">)</span><span class="si">}</span><span class="s2"> (vs </span><span class="si">{</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coordinates_upstream</span><span class="p">))</span><span class="si">}</span><span class="s2"> original)&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">return_downstream_skeletal_length</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mean_coordinates</span><span class="p">,</span><span class="n">downstream_skeletal_lengths</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mean_coordinates</span></div>
    
<div class="viewcode-block" id="clean_G"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.clean_G">[docs]</a><span class="k">def</span> <span class="nf">clean_G</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">debug_time</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for pulling down neuron graph obj: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">return_G</span> <span class="o">=</span>  <span class="n">nxu</span><span class="o">.</span><span class="n">fix_flipped_skeleton</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for flipping sk: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">return_G</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">fix_attribute</span><span class="p">(</span><span class="n">return_G</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for fixing attr: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">return_G</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">fix_width_inf_nan</span><span class="p">(</span><span class="n">return_G</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for fixing width inf: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">remove_small_starter_branches</span><span class="p">:</span>
        <span class="n">return_G</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">remove_small_starter_branches</span><span class="p">(</span><span class="n">return_G</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">remove_small_endnode_branches</span><span class="p">:</span>
        <span class="n">return_G</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">remove_small_endnode_branches</span><span class="p">(</span><span class="n">return_G</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">return_G</span></div>

<div class="viewcode-block" id="node_compartment_color_dict"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.node_compartment_color_dict">[docs]</a><span class="k">def</span> <span class="nf">node_compartment_color_dict</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">compartment_color_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    
    
    <span class="n">comp_colors</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">compartment_colors</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">compartment_color_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">comp_colors</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">compartment_color_dict</span><span class="p">)</span>
    
    <span class="n">color_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([</span>
        <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">comp_colors</span><span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;compartment&quot;</span><span class="p">]])</span>
         <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">color_dict</span></div>

<div class="viewcode-block" id="print_compartment_colors"><a class="viewcode-back" href="../../neuron_morphology_tools.html#neuron_morphology_tools.neuron_nx_utils.print_compartment_colors">[docs]</a><span class="k">def</span> <span class="nf">print_compartment_colors</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Compartment Colors&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;------------------&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">nxu</span><span class="o">.</span><span class="n">compartment_colors</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> : </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<span class="c1">#     #4) Return the branches are convert them to coordinates</span>
<span class="c1">#     if return_coordinates:</span>
<span class="c1">#         return </span>
<span class="c1">#     else:</span>
<span class="c1">#         return nodes</span>

<span class="c1">#--- from neuron_morphology_tools ---</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">morphopy_utils</span> <span class="k">as</span> <span class="n">mpu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_nx_feature_processing</span> <span class="k">as</span> <span class="n">nxf</span>  
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_nx_stats</span> <span class="k">as</span> <span class="n">nxst</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_skeleton_utils</span> <span class="k">as</span> <span class="n">nsku</span>

<span class="n">swc_df_from_file</span> <span class="o">=</span> <span class="n">mpu</span><span class="o">.</span><span class="n">swc_df_from_file</span>

<span class="c1">#--- from datasci_tools ---</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">file_utils</span> <span class="k">as</span> <span class="n">fileu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">ipyvolume_utils</span> <span class="k">as</span> <span class="n">ipvu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">mesh_utils</span> <span class="k">as</span> <span class="n">meshu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">networkx_utils</span> <span class="k">as</span> <span class="n">xu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">numpy_utils</span> <span class="k">as</span> <span class="n">nu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">pandas_utils</span> <span class="k">as</span> <span class="n">pu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">system_utils</span> <span class="k">as</span> <span class="n">su</span>
<span class="kn">from</span> <span class="nn">datasci_tools.tqdm_utils</span> <span class="kn">import</span> <span class="n">tqdm</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_nx_utils</span> <span class="k">as</span> <span class="n">nxu</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Brendan Celii.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>